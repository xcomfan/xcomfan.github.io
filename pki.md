---
layout: page
title: "Public Key Infrastructure"
permalink: /pki
---

## TL;DR

The goal of certificates and PKI is to bind names to public keys.

## Overview and Terms

* An **entity** is anything that exists even if only logically or conceptually.

* Every **entity** has an **identity**. **Identity** is some set of attributes that make the entity identifiable.

* An **identifier** is not the same as an identity; its a unique reference to some **entity**. **Identifier** is synonymous with name.

* **Entities** can claim that they have some particular name. Other **entities** might be able to authenticate that claim, confirming its true.

* **Authentication** is the process of confirming the truth of some claim.

* A **subscriber** or **end entity** is an **entity** that's participating in a PKI and can be the **subject** of a certificate.

* A **certificate authority (CA)** is an entity that issues certificates to subscribers - a certificate **issuer**.

* Certificates that belong to subscribers are sometimes called **entity certificates** or **leaf certificates**.

* Certificates that belong to **CAs** are usually called **root certificates** or **intermediate certificates** depending on the sort of CA.

* A **relying party (RP)** is a certificate user that verifies and trusts certificates issues by CA.

* An **entity** can be both a subscriber and a relying party.

* A single **entity** can have its own certificate and use other certificates to authenticate remote peers (what happens with mutual TLS)

Refer to [RFC 4949](https://tools.ietf.org/html/rfc4949) for detailed definitions.

## MAC and Signatures for Authentication

A **message authentication code (MAC)** is a bit of data that's used to verify which entity sent a message, and to ensure that a message hasn't been modified. The basic idea is to feed a shared secret (password) along with a message through a hash function. The hash output is a **MAC**. You send the MAC along with the message to some recipient. A recipient that also knows the shared secret can produce their own **MAC** and compare it to the one provided. Hash functions produce the same output for each input, thus if the recipient's **MAC** matches the one send by another **entity**; the recipient can be confident the message was sent by an **entity** that knows the shared secret.

Hash functions are one-way (you can't take the output of a hash function and reconstruct the input). This is critical for maintaining the confidentiality of a shared secret. If this property holds depends on how hash functions are used to build **MACs**. For this reason you should be using [HMAC](https://en.wikipedia.org/wiki/HMAC).

A **signature** is similar to a **MAC** but instead of using a shared secret you use a **key pair**(defined soon). With a **MAC**, at least two **entities** need to know the shared secret: the sender and the recipient. A valid **MAC** could have been generated by either party, and you can't tell which.

Signatures are different. A signature can be verified using a public key but can only be generated with a corresponding private key. Thus, a recipient that only has a public key can verify signatures, but can't generate them. If only one entity knows the private key you get a property called **non-repudiation**: the private key holder cant' deny (repudiate) the fact that they signed some data.

## Public Key Cryptography

Certificates and PKI are built on **public key cryptography** also called **asymmetric cryptography**, which uses **key pairs**. A key pair consists of a **public key** that can be distributed and shared with the world, and a corresponding **private key** that should be kept confidential by the owner.

* You can **encrypt** some data with the public key. The only way to decrypt that data is with the corresponding private key.

* You can **sign** some data with the private key. Anyone who knows the corresponding public key can verify the signature, proving which private key produced it.

This setup allows for computers to verify who they are talking to across a network. If you know my public key; you can send me a big random number and I can sign your number and send you my signature. Verifying that signature is good evidence that you are talking to me.

## Certificates

Certificates come into play when you don't yet know a public key for a host/system. A certificate is a data structure that contains a **public key** and a name. The data structure is then **signed**. The signature binds the public key to the name. The entity that signs a certificate is called the **issuer** (or **certificate authority**) and the entity named in the certificate is called the **subject**.

An issuer signing a certificate for Bob effectively means that some issuer says that Bob's public key is 01:23:42... This is a claim made by some issuer about Bob. The claim is signed by some issuer, so if you know Some Issuer's public key you can authenticate it by verifying the signature. If you trust some issuer you can trust the claim.

## X.509, ASN.1 OIDs, DER, PEM, PKCS ...

When people talk about certificates, most of the time they are talking about **X.509 v3** certificates. More specifically the PKIX variant described in [RFC 5280](https://tools.ietf.org/html/rfc5280). These are the types of certificates that browsers user for HTTPS. There are other certificate formats (both SSH and PGP have their own). Here we focus on the X.509 which conceptually is similar to the others. X.509 work out of the box with TLS and HTTPS clients and servers.

Most certificates are packaged up in **PEM (Privacy Enhanced Email)** files. The reason for this is certificates are encoded using distinguished encoding rules **DER** which is a binary format. Since binary data is hard to pass around **PEM** is a textual representation.  **PEM** is a base64 encoding sandwiched between a header and a footer. The header has a payload that describes the payload, but most tools are inconsistent on the header.

**PEM** encoded certificates typically have a `.pem`, `.crt`. or `.cer` extension. A raw certificate encoded using **DER** will usually carry a `.der` extension. You will encounter inconsistency on this.

Certificates can be wrapped in several envelope formats. When some things ask for a "certificate" what they really want is a certificate wrapped in one of these envelopes. The envelope formats are part of a standard knowns as **PKCS (Public Key Cryptography Standards)**.

The first is **PKCS#7** re-branded as **CMS ([Cryptographic Message Syntax](https://tools.ietf.org/html/rfc5652))** which can contain one or more certificates (encoding a full certificate chain). **PKCS#7** is commonly used by Java and common extensions are `.p7b` and `p7c`.

The other common envelope type is **PKCS#12** which can contain a certificate chain (like PKCS#7) along with an encrypted private key. **#PKCS#12** is commonly used in Microsoft products and common extensions are `.pfx` and `.p12`. Usually both of these are encoded with DER.

Key encoding is usually in DER format for binary or PEM format for textual.

Public keys will usually have a `.pub` or `.pem` extensions. Private keys may carry a `.prv` or `.key` or `.pem` extension.

To sum up. ASN.1 is used to define data types like certificate and keys. DER is a set of encoding rules for turning ASN1. into binary. X.509 is defined in ASN.1. Since raw binary DER is hard to send around the web most certificates are PEM-encoded. Private keys are also typically stored as PEM encoded and usually encrypted with a password.

## Public key Infrastructure

**Public key infrastructure (PKI)** is the umbrella term for all of the stuff we need in order to issue, distribute, store, use, verify, revoke, and otherwise manage and interact with certificates and keys. In addition to certificates and certificate authorities PKI also includes libraries, cron jobs, protocols, convention, clients, servers, people, processes etc.

## Web PKI vs Internal PKI

### Web PKI

Web PKI is mostly defined by [RFC 5280](https://tools.ietf.org/html/rfc5280) and refined by [CA/Browser Forum](https://cabforum.org/). It has details on what a name is and where it goes in a certificate, what signature algorithm can be used, how a relying party determines the issuer of a certificate, how a certificate validity period is specified. Web PKI is important because web PKI certificates work by default with browser and pretty much everything else that uses TLS.

### Internal PKI

Internal PKI is PKI you run yourself. Its used for services, containers, VMs IT applications etc. Reason to run your own PKI is that you have little or no control over details such as certificate lifetime, revocation mechanisms, renewal processes, key types and algorithms if you rely on web PKI. Also Web PKI CAs are prohibited from binding to internal (non public) IPs or internal DNS names that aren't fully qualified and resolvable via global DNS.

You want to use Web PKI for APIs and public facing websites, but internal PKI for everything else.

## Trust and Trustworthiness

### Trust Stores

Earlier we defined a certificate as a claim "issue cays subject's public key is X". This claim is signed by the issuer so it can be authenticated by relying parties. How does the relying party know the issuer's public key though? Relying parties are pre-configured with a list of trusted **root certificates** (or trust anchors) in a **trust store**.

The manner in which this pre-configuration occurs in an important aspect of any PKI. One option is to bootstrap from another PKI: you could have some automation tool use SSH to copy root certificates to relying parties, leveraging the SSH PKI. If you are running in the cloud your SSH PKI is bootstrapped off of Web PKI plus whatever authentication your cloud vendor set up when creating your account. Follow the chain long enough and at the core is always people.

Root certificates in trust stores are **self signed**. The issuer and the subject are the same. The signature on a self-signed certificate provides assurance that the subject/issuer knows the relevant private key, but anyone can generate a self-signed certificate with any name they want in it. A self signed certificate should only be trusted insofar as the process by which it made its way into the **trust store**.

On macOS the trust store is managed by the keychain. On many Linux distributions it's simply some file(s) in `/etc` or elsewhere on disk. If users can modify these files you better trust all your users.

For Web PKI the most important relying parties are web browsers. The trust stores used by default by the major browsers and pretty much everything else that uses TLS are maintained by [Apple's root certificate program](http://www.apple.com/certificateauthority/ca_program.html) used by iOS and macOS, [Microsoft's root certificate program](https://social.technet.microsoft.com/wiki/contents/articles/31633.microsoft-trusted-root-program-requirements.aspx) used by Windows, [Mozilla's root certificate program](https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/) used by their products and, because of its open and transparent process, used as the basis for many other trust stores (many Linux distributions), and [Google's root certificate program](https://g.co/chrome/root-policy) used by Chrome and all platforms except iOS. These trust stores usually ship with the OS or browser and are updated with software updates (usually signed using yet another PKI). The major CAs are included in these trust stores such as LetsEncrypt, Symantec, DigiCert, Entrust etc.

Cloudflare [cfssl](https://github.com/cloudflare/cfssl) project maintains a github repository that included trusted certificates from various trust stores to assist with certificate bundling.  You can also query [Censys](https://censys.io/) to see which certificates are trusted by Mozilla, Apple, and Microsoft. 

### Trustworthiness

While these 100+ certificate authorities are trusted by browser it does not mean they are necessarily trustworthy. You don't really know who runs them and if they are compromised in some way. For this reason if you are using TLS for internal stuff you probably don't want to trust these external authorities.

[Certificate Authority Authorization (CAA)](https://tools.ietf.org/html/rfc6844) allow you to restrict which CAs can issue certificates for your domain using a special DNS record. [Certificate Transparency (CT)](https://www.certificate-transparency.org/) mandates that CAs submit every certificate they issue to an impartial observer that maintains a [public certificate log](https://crt.sh/?Identity=smallstep.com) to detect fraudulently issued certificates. [HTTP Public Key Pinning](https://tools.ietf.org/html/rfc7469) (HPKP or just "pinning") lets a subscriber (a website) tell an RP (a browser) to only accept certain public keys in certificates for a particular domain.

The problem with a lot of this is many browsers (RPs) do not support or enforce it.

If you run your own PKI you should maintain a separate trust store for internal stuff. Instead of adding your root certificate(s) to the existing system trust store, configure internal TSL requests to use only your roots. If you want better federation internally (you want to restrict whic certifcates your internal CAs can issue) you might try CAA records and properly configured RPs. You may also want to check out [SPIFFE](https://spiffe.io/), an evolving standardization effort that addresses this problem and a number of others related to internal PKI.

## What is a Certificate Authority

A CA is a trusted certificate issuer. It vouches for the binding between a public key and a name by signing a certificate. Fundamentally, a certificate authority is just another certificate and a corresponding private key that's used to sign other certificates. Some logic and process is needed around these artifacts. The CA needs to get its certificate distributed in trust stores, accept and process certificate requests, and issue certificates to subscribers. A CA that exposes remotely accessible APIs to automate this stuff is called an *online* CA. A CA with a self-signed root certificate included in trust stores is called a *root* CA.

### Intermediates, Chains, and Bundling

Based on requirements in [CAB Forum Baseline Requirements](https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.1.pdf) Web PKI root CAs can't automate certificate signing. They can't be online which is a problem for any large scale operation. The reason for this stipulation is security. Since Web PKI root certificates are broadly distributed in trust stores they are are hard to revoke. Compromising a root CA private key would affect billions of people and devices. Therefore it is best practice to keep root private keys offline with good security.

To make certificate issuance scalable (automated) the root private key is only used infrequently to sign a few **intermediate certificates**. The corresponding intermediate private keys are used by intermediate CAs (also called subordinate CAs) to sign and issue leaf certificates to subscribers. Intermediates aren't included in trust stores, making them easier to revoke and rotate, so certificate issuance form an intermediate typically is online and automated.

This **bundle** of certificates -- leaf, intermediate, root forms a chain (called a **certificate chain**). The leaf is signed by the intermediate, the intermediate by the root and the root signs itself. You can create longer chains and cross certification with this mechanism.

### Certificate path validation

Since intermediate certificates are not included in trust stores, they need to be distributed and verified just like leaf certificates. With TLS this happens as part of the handshake that establishes a TLS connection. When a subscriber sends a certificate to a relying it includes any intermediate(s) necessary to chain bak up to a trusted root. The relying party verifies the leaf and itermediate certificates in a process called **certificate path validation**. This process includes checking certificate expirations, revocation status and a bunch of other stuff. This is the part of TLS that does the authentication.

## Key and Certificate Lifecycle

The process of getting a certificate from a CA eventfully is a subscriber generating a key pair and submitting a request to a CA. The CA makes rue the name that will be bound in the certificate is correct and if it is signs and returns the certificate. Certificates do expire at which point they are not longer trusted byt he RPs. If you want RPs to stop trusting a certificate it can sometimes be revoked.

### Naming

A Common Name is all you need in a certificate. Locality, country, organization, unit is all pretty irrelevant. Same for distinguished names. The modern best practice is to leverage the [subject alternative name (SAN) X.509 extension](https://tools.ietf.org/html/rfc5280#section-4.2.1.6).

There are 4 sorts of SANs in common use, all of which bind names that are broadly used and understood.

* Domain names (DNS)
* email addresses
* IP addresses
* URLs

Web PKI allows for multiple names to be bound in a certificate and allows for wildcards in names. This is useful for websites that respond to multiple names ( google.com and www.google.com for example).

### Generating key pairs

Recall that the security of PKI depends on only the entity that knows a private key being the subscriber names in the corresponding certificate. To make sure this holds its best practice to have the subscriber generate their own key pair. 

For the type of key to use; There is a slow transition from using RSA to elliptic curve keys (ECDSA or EdSA). If using RSA make them at least 2048 bits, and don't bother with anything bigger than 4096 bits. Use RSA-PSS not RSA PKCS#1. If you use ECDSA, the P-256 curve is probably best (secp256k1 or prime256v1 in openss).

Example of generating a elliptic curve P-256 key pair using openssl:

```bash
openssl ecparam -name prime256v1 -genkey -out k.prv
openssl ec -in k.prv -pubout -out k.pub
```

### Issuance

Once a subscriber has a name and a keypair the next step is to obtain a leaf certificate from a CA. The CA is going to want to authenticate 2 tings.

* The public key to be bound in the certificate is the subscriber's public key (i.e., the subscriber knows the corresponding private key)

* The name to be bound in the certificate is the subscribers name

The first is typically achieved via a certificate signing request. The second is done though some sort of identity proofing or registration.

#### Certificate Signing Requests

The certificate sign request (CSR) is an ASN.1 structure defined by [PKCS#10](https://tools.ietf.org/html/rfc2986). Like a certificate the CSR contains a public key that corresponds to the public key in the CSR. This signature proves that whatever created the CSR knows the private key. It also allows the CSR to be copy and pasted and sent around without risk of being tampered with.

You can generate a csr via openssl.

#### Identify Proofing

For Web PKI thee are three kinds of certificates mainly differing on how they identify subscribers and the sort of identity proofing that's employed.

* Domain validation (DV) - bind a DNS name and are issued based on proof of control over a domain name.
* Organization validation (OV) - Build on DV but include the name and location of organization that owns the bound domain. 
* Extended validation (EV) - Similar to OV but has stricter more consistent verification. Not widely leveraged by web PKI because browser don't really differentiate between DV and EV certs.

For internal PKI you can use any process you want for identity proofing. You proving infrastructure just need to have some form of identity.

#### Expiration

X.509 certificates include a validity period. A not before (issue time) and not after (expiration time).

#### Renewal

There is no standard renewal process for Web PKI. You just replace the existing certificate with a new one; thus the renewal process is the same as the issue process.

For internal PKI the easiest thing to do is to use your old certificate with a protocol like mutual TLS to renew. The CA can authenticate the client certificate presented by the subscriber, re-sign it with an extended expiry, and return the new certificate in response. This makes automated renewal very easy and still forces subscribers to periodically check in with a central authority.

Hardest part is simply remembering to renew your certificates. The best advice here is if something hurts, do it more. Use short lived certs that will force you to improve processes and automate.

If you have `step` set up you can use it toc heck expiry date of a certificate.

```bash
step certificate inspect cert.pem --format json | jq .validity.end
step certificate inspect https://smallstep.com --format json | jq .validity.end
```

The above combined with a DNS zone transfer in a bash file can be used to monitor certificate expiration.

#### Revocation

Revoking X.509 certificates is a big mess. Since the RPs are responsible for enforcing if a cert is valid, and unlike the expiration date the revocation status cannot be encoded into the certificate; the RP has to determine if a certificate is revoked though some out of band process. Unless configured for this, most Web PKI TLS RPs don't bother to check.

For internal PKIs short lived certificates and passive revocation is typically used. If keeping cert renewal times very low (5 minutes etc.) make sure that your clicks are synced or your going to have a bad time.

There are some options such as Certificate Revocation Lists (CRLs) and Online Certificate Signing Protocols (OCSP) which allow you to query an OCSP responder with a certificate serial number to obtain the revocation status. Like the CRL distribution point, the OCSP responder URL is included in the certificate. There are issues with OCSP. For one it will know all sites being visited based on the certificate being checked. It also add the overhead of an extra check and like CRLs you can fail open (check is down so you assume cert is good). 

## Summary

[Smallsetp Certificate Manager](https://smallstep.com/certificate-manager) can help with building and internal PKI.


## Handy openssl Commands

```bash
openssl x509 -in my_cert.pem -noout -subject
openssl x509 -in my_cert.pem -noout -issuer
openssl x509 -in my_cert.pem -noout -subject
openssl x509 -in my_cert.pem -noout -issuer
openssl x509 -in my_cert.pem -noout -fingerprint
openssl x509 -in my_cert.pem -noout -serial
```

These flags can be combined to get multiple output at the same time.