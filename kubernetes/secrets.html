<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Kubernetes Secrets | My References</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Kubernetes Secrets" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<link rel="canonical" href="http://0.0.0.0:4000/kubernetes/secrets" />
<meta property="og:url" content="http://0.0.0.0:4000/kubernetes/secrets" />
<meta property="og:site_name" content="My References" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Kubernetes Secrets" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","headline":"Kubernetes Secrets","url":"http://0.0.0.0:4000/kubernetes/secrets"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="My References" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My References</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Kubernetes Secrets</h1>
  </header>

  <div class="post-content">
    <h2 id="what-are-secrets-in-kubernetes">What are Secrets in Kubernetes?</h2>

<p>Secrets are similar to <a href="/kubernetes/config_maps">ConfigMaps</a> but focus on making sensitive information available to the workload. They can be used for things like credentials or TLS certificates. Secrets are exposed to Pods via explicit declaration in Pod manifests and the Kubernetes API. In this way, the Kubernetes secrets API provides an application centric mechanism for exposing sensitive configuration information to applications in a way that’s easy to audit and leverages native OS isolation primitives.</p>

<p><strong><em>Note:</em></strong> By default, Kubernetes secrets are stored in plain text in <code class="language-plaintext highlighter-rouge">etcd</code> storage for the cluster. This may not be sufficient security depending on your requirements. Anyone who has cluster admin rights will be able to read all of the secrets in the cluster. Recent versions of Kubernetes add support for encrypting the secrets with a user supplied key which is generally integrated into a cloud key store. Most cloud key stores have integrations with Kubernetes flexible volumes, enabling you to skip Kubernetes secrets entirely and rely on the cloud providers key store.</p>

<h2 id="creating-secrets">Creating Secrets</h2>

<p>Secretes hold one or more data elements as a collection of key/value pairs and are created either with Kubernetes API or the kubectl command-line tool.</p>

<p>Below is an example of using the <code class="language-plaintext highlighter-rouge">kubectl</code> command to created a secret which stores a TLS certificate and key from files local on the system where the command is being run. The command will create a secret with two elements <code class="language-plaintext highlighter-rouge">kuard.crt</code> and <code class="language-plaintext highlighter-rouge">kuard.key</code></p>

<p><code class="language-plaintext highlighter-rouge">kubectl create secret generic kuard-tls --from-file=kuard.crt --from-file=kuard.key</code></p>

<p>To view the secret use the command below</p>

<p><code class="language-plaintext highlighter-rouge">kubectl describe secrets kuard-tls</code></p>

<p>When creating Secrets keep in mind the <a href="/kubernetes/naming_constraints">naming constraints</a> for the key names in a Secret. The maximum size for a Secret in Kubernetes is 1MB.</p>

<h2 id="consuming-secrets">Consuming Secrets</h2>

<p>Secrets can be consumed using the Kubernetes REST API by applications that know how to call that API directly. This approach may not be desirable as this makes your application not portable (will only work in Kubernetes). Another option is to use a <strong>secrets volume</strong>.</p>

<h3 id="secrets-volumes">Secrets volumes</h3>

<p>Secret data can be exposed to Pods using the secrets volume type. Secret volumes are managed by the <code class="language-plaintext highlighter-rouge">kubelet</code> and are created at Pod creation time. Secrets are stored on <code class="language-plaintext highlighter-rouge">tmpfs</code> volumes (aka RAM disks), and as such are not written to disk on nodes. Each element of a secret is stored in a separate file under the target mount point specified in the volume mount.</p>

<p>The below Pod manifest demonstrates how to declare a secrets volume which exposes the <code class="language-plaintext highlighter-rouge">kuard-tls</code> secret volume to <code class="language-plaintext highlighter-rouge">/tls</code> mount point.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kuard-tls</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">kuard-tls</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">gcr.io/kuar-demo/kuard-amd64:blue</span>
      <span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">Always</span>
      <span class="na">volumeMounts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tls-certs</span>
        <span class="na">mountPath</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/tls"</span>
        <span class="na">readOnly</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tls-certs</span>
      <span class="na">secret</span><span class="pi">:</span>
        <span class="na">secretName</span><span class="pi">:</span> <span class="s">kuard-tls</span>
</code></pre></div></div>

<h3 id="private-docker-registries">Private Docker registries</h3>

<p>A special use case for secretes is to store access credentials for private Docker registries. Private Docker images can be stored across one or more private registries. This presents a challenge for managing credentials for each private registry on every possible node in the cluster. <strong>Image pull secrets</strong> leverage the secrets API to automate the distribution of private registry credentials. Image pull secrets are stored just like normal secrets but are consumed through the <code class="language-plaintext highlighter-rouge">spec.imagePullSecrets</code> Pod specification field.</p>

<p>Use the <code class="language-plaintext highlighter-rouge">create secret docker-registry</code> to create this special kind of secret. For example <code class="language-plaintext highlighter-rouge">kubectl create secret docker-registry my-image-pull-secret --docker-username=&lt;username&gt; --docker-password=&lt;password&gt; --docker-email=&lt;email-address&gt;</code></p>

<p>You then enable access to the private repository by referencing the image pull secret in the Pod manifest file as in the example below.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kuard-tls</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">kuard-tls</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">gcr.io/kuar-demo/kuard-amd64:blue</span>
      <span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">Always</span>
      <span class="na">volumeMounts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tls-certs</span>
        <span class="na">mountPath</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/tls"</span>
        <span class="na">readOnly</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">imagePullSecrets</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span>  <span class="s">my-image-pull-secret</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tls-certs</span>
      <span class="na">secret</span><span class="pi">:</span>
        <span class="na">secretName</span><span class="pi">:</span> <span class="s">kuard-tls</span>
</code></pre></div></div>

<p>If you are repeatedly pulling from the same registry, you can add the secrets to the default service account associated with each Pod to avoid having to specify the secrets in every Pod you create.</p>

<h2 id="managing-configmaps-and-secrets">Managing ConfigMaps and Secrets</h2>

<p>Secrets and ConfigMaps are managed through the Kubernetes API. The usual <code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">delete</code>, <code class="language-plaintext highlighter-rouge">get</code> and <code class="language-plaintext highlighter-rouge">describe</code> commands work for manipulating these objects.</p>

<h3 id="listing">Listing</h3>

<p><code class="language-plaintext highlighter-rouge">kubectl get secrets</code></p>

<p><code class="language-plaintext highlighter-rouge">kubectl describe secrets my-config</code></p>

<h3 id="creating">Creating</h3>

<p>The easiest way to create a Secret is via <code class="language-plaintext highlighter-rouge">kubectl create secret generic</code> There are a variety of ways to specify the data items that go into the secret. These can be combined in a single command.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--from-file=&lt;filename&gt;</code> - Load from the file with the secret data key the same as the filename</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--from-file=&lt;key&gt;=&lt;filename&gt;</code> - Load from the file with the secret data key explicitly specified</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--from-file=&lt;directory&gt;</code> - Load all files in the specified directory where the filename is an acceptable key name</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--from-literal=&lt;key&gt;=&lt;value&gt;</code> - Use the specified key/value pair directly</p>
  </li>
</ul>

<h3 id="updating">Updating</h3>

<p>You can update a Secret and have it reflected in running programs. There is no need to restart if the application is configured to reread configuration values. This is a rare feature but might be something you can add to your applications.</p>

<p>Below are three ways to update Secrets.</p>

<h4 id="update-from-file">Update from file</h4>

<p>If you have a manifest for your Secret, you can just edit it directly and push a new version with <code class="language-plaintext highlighter-rouge">kubectl replace -f &lt;filename&gt;</code> You can also use <code class="language-plaintext highlighter-rouge">kubectl apply -f &lt;filename&gt;</code> if you previously created the resource with kubectl apply. Due to the way that data files are encoded into these objects, updating a configuration can be a bit cumbersome as there is no provision in <code class="language-plaintext highlighter-rouge">kubectl</code> to load data from an external file. The data must be stored directly in the YAML manifest. The most common use case is when the Secret is defined as part of a directory or list of resources and everything is created and updated together. Oftentimes these manifests will be checked into source control. Be careful not put push secrets into a public location.</p>

<h4 id="recreate-and-update">Recreate and update</h4>

<p>If you store the inputs into your Secrets as separate files on disk (as opposed to embedded into YAML directly), you can use <code class="language-plaintext highlighter-rouge">kubectl</code> to recreate the manifest and then use it to update the object. This will look something like…</p>

<p><code class="language-plaintext highlighter-rouge">kubectl create secret generic kuard-tls --from-file=kuard.crt --from-file=kuard.key --dry-run -o yaml | kubectl replace -f -</code></p>

<p>This command line first creates a new secret with the same name as our existing secret. If we just stopped there, the Kubernetes API server would return an error complaining that we are tying to create a secret that already exists. Instead, we tell <code class="language-plaintext highlighter-rouge">kubectl</code> not to actually send the data to the server but instead to dump the YAML that it <em>would have</em> sent to the API server to <code class="language-plaintext highlighter-rouge">stdout</code>. We then pipe that to <code class="language-plaintext highlighter-rouge">kubectl</code> replace and use <code class="language-plaintext highlighter-rouge">-f -</code> to tell it to read from <code class="language-plaintext highlighter-rouge">stdin</code>. In this way we can update a secret from files on disk without having to manually base64 encode the data.</p>

<h4 id="live-updates">Live updates</h4>

<p>Once a Secret is updated using the API, it will automatically be pushed to all volumes that use that ConfigMap or secret. This update may take a few seconds. Currently there is not built in way to signal an application when a new version of ConfigMap is deployed. It is up to the application or some helper script to look for the config files to change and reload them.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My References</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My References</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
