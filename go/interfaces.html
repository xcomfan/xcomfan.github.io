<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Go Interfaces | My References</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Go Interfaces" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<link rel="canonical" href="http://0.0.0.0:4000/go/interfaces" />
<meta property="og:url" content="http://0.0.0.0:4000/go/interfaces" />
<meta property="og:site_name" content="My References" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Go Interfaces" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","headline":"Go Interfaces","url":"http://0.0.0.0:4000/go/interfaces"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="My References" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My References</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Go Interfaces</h1>
  </header>

  <div class="post-content">
    <h2 id="interface-basics">Interface basics</h2>

<p>An <strong>interface type</strong> is defined as a set of method signatures but no implementation.  A value of interface type can hold any value that implements those methods.</p>

<p>Interfaces are implemented implicitly. A type implements an interface by implementing its methods.  There is no explicit declaration of intent (no implements keyword or anything like that).  Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement.</p>

<p>A good way to think about interfaces.  Think of the shapes circle, triangle and square. If we use interfaces to give each an area method and call the interface Shape, we can now create a slice of shapes.  Even though they are different structs because they implement the same interface we can treat them as the same type and stick them into a slice.  More concrete example of this in Go IO reader is an interface and using this same interface you can work with files, sockets, compressed files etc.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"math"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Abser</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">MyFloat</span> <span class="kt">float64</span>

<span class="k">func</span> <span class="p">(</span><span class="n">f</span> <span class="n">MyFloat</span><span class="p">)</span> <span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">float64</span><span class="p">(</span><span class="o">-</span><span class="n">f</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">float64</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Vertex</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vertex</span><span class="p">)</span> <span class="n">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">X</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">a</span> <span class="n">Abser</span>
    <span class="n">f</span> <span class="o">:=</span> <span class="n">MyFloat</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">Sqrt2</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">:=</span> <span class="n">Vertex</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">f</span>  <span class="c">// a MyFloat implements Abser</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span> <span class="c">// a *Vertex implements Abser</span>

    <span class="c">// In the following line, v is a Vertex (not *Vertex)</span>
    <span class="c">// and does NOT implement Abser.</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Abs</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="interface-values">Interface values</h2>

<p>Under the hood, interface values can be thought of as a tuple of a value and a concrete type <code class="language-plaintext highlighter-rouge">(value, type)</code>.  An interface value holds a value of a specific underlying concrete type.  Calling a method on an interface value executes the method of the same name on its underlying type.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"math"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">MyInterface</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">MyInterfaceMethod</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">MyType</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">S</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">MyType</span><span class="p">)</span> <span class="n">MyInterfaceMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">MyFloat</span> <span class="kt">float64</span>

<span class="k">func</span> <span class="p">(</span><span class="n">f</span> <span class="n">MyFloat</span><span class="p">)</span> <span class="n">MyInterfaceMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="n">MyInterface</span>

    <span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MyType</span><span class="p">{</span><span class="s">"Hello"</span><span class="p">}</span>
    <span class="n">describe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span><span class="o">.</span><span class="n">MyInterfaceMethod</span><span class="p">()</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">MyFloat</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Pi</span><span class="p">)</span>
    <span class="n">describe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span><span class="o">.</span><span class="n">MyInterfaceMethod</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">describe</span><span class="p">(</span><span class="n">i</span> <span class="n">MyInterface</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"(%v, %T)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="interface-values-with-nil-underlying-values">Interface values with nil underlying values</h3>

<p>If the concrete value inside the interface itself is <code class="language-plaintext highlighter-rouge">nil</code>, the method will be called with a <code class="language-plaintext highlighter-rouge">nil</code> receiver.  While in most languages this would trigger a null pointer exception in Go its common to write methods that gracefully handle being called with a <code class="language-plaintext highlighter-rouge">nil</code> receiver (as with the method <code class="language-plaintext highlighter-rouge">M</code> in example below)</p>

<p><strong><em>NOTE:</em></strong> An interface value that holds a nil concrete value is itself non-nil.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">I</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">M</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">S</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"&lt;nil&gt;"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="n">I</span>

    <span class="k">var</span> <span class="n">t</span> <span class="o">*</span><span class="n">T</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">describe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>

    <span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">{</span><span class="s">"hello"</span><span class="p">}</span>
    <span class="n">describe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">describe</span><span class="p">(</span><span class="n">i</span> <span class="n">I</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"(%v, %T)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nil-interface-values">Nil interface values</h3>

<p>A <code class="language-plaintext highlighter-rouge">nil</code> interface value holds neither value nor concrete type.  Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which <em>concrete</em> method to call.</p>

<p><em>Example below throws a runtime error</em>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">I</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">M</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="n">I</span>
    <span class="n">describe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">describe</span><span class="p">(</span><span class="n">i</span> <span class="n">I</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"(%v, %T)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="empty-interfaces">Empty interfaces</h2>

<p>If you have an interface with no methods at all that is an <strong>empty interface</strong> <code class="language-plaintext highlighter-rouge">interface{}</code>.  An empty interface is a way to express that object could be anything.  Empty interfaces are used by code that handles values of unknown type.  For example <code class="language-plaintext highlighter-rouge">fmt.Print</code> takes any number of interfaces of type <code class="language-plaintext highlighter-rouge">interface{}</code></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">interface</span><span class="p">{}</span>
    <span class="n">describe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="m">42</span>
    <span class="n">describe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="s">"hello"</span>
    <span class="n">describe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">describe</span><span class="p">(</span><span class="n">i</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"(%v, %T)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// declare the empty interface</span>
    <span class="c">// any type in go will match it even built in types</span>
    <span class="c">// its a way to say this could be anything like Object type in Java</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">interface</span><span class="p">{}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="s">"Hello"</span>
    <span class="c">// assert the type behind i is a sting and assign it to j</span>
    <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
    <span class="c">// ok will be assigned to a bool of assertion result</span>
    <span class="c">// if the assertion is true, k will be assigned the value if it fails</span>
    <span class="c">// k will be assigned the 0 value of that type.</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
    <span class="c">// line below will panic if assertion fails</span>
    <span class="c">// use the k, ok version above if doing type assertions</span>
    <span class="c">// m := i.(int)</span>
    <span class="c">// fmt.Println(m)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="getting-the-concrete-type-behind-an-interface">Getting the concrete type behind an interface</h2>

<p>A type assertion provides access to an interface value’s underlying concrete type.  <code class="language-plaintext highlighter-rouge">t := i.(T)</code> This statement asserts that the interface value <code class="language-plaintext highlighter-rouge">i</code> holds the concrete type <code class="language-plaintext highlighter-rouge">T</code> and assigns the underlying <code class="language-plaintext highlighter-rouge">T</code> value to the variable <code class="language-plaintext highlighter-rouge">t</code>.  If <code class="language-plaintext highlighter-rouge">i</code> does not hold a <code class="language-plaintext highlighter-rouge">T</code>, the statement will trigger a panic.  To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded. <code class="language-plaintext highlighter-rouge">t, ok := i.(T)</code> If <code class="language-plaintext highlighter-rouge">i</code> holds a <code class="language-plaintext highlighter-rouge">T</code>, then <code class="language-plaintext highlighter-rouge">t</code> will be the underlying value and <code class="language-plaintext highlighter-rouge">ok</code> will be true.  If not, <code class="language-plaintext highlighter-rouge">ok</code> will be false and <code class="language-plaintext highlighter-rouge">t</code> will be the zero value of type <code class="language-plaintext highlighter-rouge">T</code>, and no panic occurs.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="s">"hello"</span>

    <span class="n">s</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="n">s</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>

    <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span> <span class="c">// panic</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="type-switches-with-interfaces">Type switches with interfaces</h3>

<p>A <strong>type switch</strong> is like a regular switch statement, but the cases in a type switch are specifically types (not values), and those value are compared against the type of the value held by the given interface value.  The declaration in a type switch has the same syntax as a type assertion <code class="language-plaintext highlighter-rouge">i.(T)</code>, but the specific type <code class="language-plaintext highlighter-rouge">T</code> is replaced with the keyword <code class="language-plaintext highlighter-rouge">type</code>.  The switch statement tests whether the interface value <code class="language-plaintext highlighter-rouge">i</code> holds a value of type <code class="language-plaintext highlighter-rouge">T</code> or <code class="language-plaintext highlighter-rouge">S</code>.  In the default case (where there is no match), the variable <code class="language-plaintext highlighter-rouge">v</code> is of the same interface type and value as <code class="language-plaintext highlighter-rouge">i</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">doStuff</span><span class="p">(</span><span class="n">i</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="c">// type is a keyword and by convention the variable on the left hand side</span>
    <span class="c">// of := re-uses the variable on the right hand side in a type assertion</span>
    <span class="k">switch</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">int</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Double i is"</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
    <span class="k">case</span> <span class="kt">string</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"i is"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s">"characters long"</span><span class="p">)</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"I don't know what to do with this."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">doStuff</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
    <span class="n">doStuff</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
    <span class="n">doStuff</span><span class="p">(</span><span class="no">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="making-a-function-implement-an-interface">Making a function implement an interface</h2>

<p>You can make a function implement an interface by defining a function type and a method on the function type.</p>

<p>This lets you convert functions with the right functions signature into instances of a type.  Lets you use closure as an instance of an interface.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">tester</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">test</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">runTests</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tests</span> <span class="p">[]</span><span class="n">tester</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">:=</span> <span class="no">true</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tests</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">test</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>

<span class="c">// type testerFunc that is of type function that takes in int and returns a bool</span>
<span class="k">type</span> <span class="n">testerFunc</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>

<span class="c">// declare method on testerFunc that takes in an int and returns a bool.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">tf</span> <span class="n">testerFunc</span><span class="p">)</span> <span class="n">test</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c">// call the underlying function and return its return value.</span>
    <span class="c">// because testerFunc has method that takes an int and returns a bool</span>
    <span class="c">// it effectively implements the tester interface..</span>
    <span class="k">return</span> <span class="n">tf</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">:=</span> <span class="n">runTests</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="p">[]</span><span class="n">tester</span><span class="p">{</span>
        <span class="c">// anonymous function that uses type conversion to make it into a testerFunc</span>
        <span class="c">// provides behavior for interface on the fly rather than having to define it before</span>
        <span class="n">testerFunc</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span><span class="o">%</span><span class="m">2</span> <span class="o">==</span> <span class="m">0</span>
        <span class="p">}),</span>
        <span class="n">testerFunc</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">20</span>
        <span class="p">}),</span>
    <span class="p">})</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<h3 id="the-empty-interface">The empty interface</h3>

<h3 id="type-assertions">Type assertions</h3>

<p>A type assertion provides access to an interface values’s underlying concrete type.</p>

<p><code class="language-plaintext highlighter-rouge">t := i.(T)</code></p>

<p>This statement asserts that the interface value <code class="language-plaintext highlighter-rouge">i</code> holds the concrete type <code class="language-plaintext highlighter-rouge">T</code> and assigns the underlying <code class="language-plaintext highlighter-rouge">T</code> value to the variable <code class="language-plaintext highlighter-rouge">t</code>.  If <code class="language-plaintext highlighter-rouge">i</code> does not hold a <code class="language-plaintext highlighter-rouge">T</code>, the statement will trigger a panic.  To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.</p>

<p><code class="language-plaintext highlighter-rouge">t, ok := i.(T)</code></p>

<p>If <code class="language-plaintext highlighter-rouge">i</code> holds a <code class="language-plaintext highlighter-rouge">T</code>, then <code class="language-plaintext highlighter-rouge">t</code> will be the underlying value and <code class="language-plaintext highlighter-rouge">ok</code> will be true.  If not, <code class="language-plaintext highlighter-rouge">ok</code> will be false and <code class="language-plaintext highlighter-rouge">t</code> will be the zero value of type <code class="language-plaintext highlighter-rouge">T</code>, and no panic occurs.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="s">"hello"</span>

    <span class="n">s</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="n">s</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>

    <span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span> <span class="c">// panic</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="stringer-interface">Stringer Interface</h2>

<p>One of the most ubiquitous interfaces is <code class="language-plaintext highlighter-rouge">Stringer</code> defined int he <code class="language-plaintext highlighter-rouge">fmt</code> package.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Stringer</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">Stringer</code> is a ty pe that can describe itself as a string.  The <code class="language-plaintext highlighter-rouge">fmt</code> package and many others look for this interface to print values.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Name</span> <span class="kt">string</span>
    <span class="n">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Person</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%v (%v years)"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Age</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Arthur Dent"</span><span class="p">,</span> <span class="m">42</span><span class="p">}</span>
    <span class="n">z</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Zaphod Beeblebrox"</span><span class="p">,</span> <span class="m">9001</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="generics">Generics</h2>

<p>Generics is a feature added in Go 1.18 that lets you use a set of types as an interface.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Ordered</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">|</span> <span class="kt">float64</span> <span class="o">|</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">min</span><span class="p">[</span><span class="n">T</span> <span class="n">Ordered</span><span class="p">](</span><span class="n">values</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="k">var</span> <span class="n">zero</span> <span class="n">T</span>
        <span class="k">return</span> <span class="n">zero</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"min of empty slice"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">m</span> <span class="o">:=</span> <span class="n">values</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">values</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="p">{</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">v</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">m</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">min</span><span class="p">([]</span><span class="kt">float64</span><span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">}))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">min</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"B"</span><span class="p">,</span> <span class="s">"A"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">}))</span>
<span class="p">}</span>
</code></pre></div></div>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My References</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My References</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
