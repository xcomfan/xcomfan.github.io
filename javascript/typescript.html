<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Typescript Reference | My References</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Typescript Reference" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<link rel="canonical" href="http://localhost:4000/javascript/typescript" />
<meta property="og:url" content="http://localhost:4000/javascript/typescript" />
<meta property="og:site_name" content="My References" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Typescript Reference" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","headline":"Typescript Reference","url":"http://localhost:4000/javascript/typescript"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="My References" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My References</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Typescript Reference</h1>
  </header>

  <div class="post-content">
    
<h1 id="intro">Intro</h1>

<ul>
  <li>Typescript is a compoiled language that compiles down to Javascript</li>
  <li>Typescript adds strong static typing on top of Javascript so that its able to provide compile time code checking.</li>
  <li>Typescript is a superset of Javascript</li>
  <li>For more infro and references got to typesriptlang.org</li>
  <li><a href="https://github.com/LinkedInLearning/typescript-EssT-2428199">GitHub repo for ourse</a></li>
</ul>

<h2 id="installing-typescrit-and-adding-it-to-your-project">Installing Typescrit and adding it to your project</h2>

<ul>
  <li>In the course we are using node and then installing typescript you can install it locally or globally.  Node is just the package manager.</li>
</ul>

<p><a href="https://nodejs.org/en">NPM Download</a></p>

<p><a href="https://www.typescriptlang.org/download">Typescript Download</a></p>

<p>Commands I used to get node installed</p>

<p><code class="language-plaintext highlighter-rouge">curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - &amp;&amp;\
sudo apt-get install -y nodejs</code></p>

<p>Command I used to install TypeScript into my project directory</p>

<p><code class="language-plaintext highlighter-rouge">npm install typescript --save-dev</code></p>

<p><strong>NOTE:</strong> <em>You will need to mess with your PATH variable to get the tsc executable in the path.  The tsc executalbe is in the node modules directory</em></p>

<p>You configure how typescript will behave with the <code class="language-plaintext highlighter-rouge">tsconfig.json</code> file in the root of your project directory.  There is an example in the sample project from the class.</p>

<p>include is where you set the paths to serach that typescript should be transpiling</p>

<p>compilerOptions directive is for the compile options</p>

<p>outDir compiler option lets you specify where your transpiled output goes.</p>

<p>target is the target language version you want to transpile to.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>esnext is a target option that outputs to latest version of Javascript (goot to use if you will also use bable).  ES6 is another option as is ES3.
</code></pre></div></div>

<p>If you want to just use Typescript for type checking an noting else you can set noEmit to true in compile options.  This will cause it to not generate any output files.</p>

<h2 id="adding-type-checking-to-javascript-files">Adding type checking to Javascript Files</h2>

<p>In your tsconfig.js file set paramers (inside of compile options) <code class="language-plaintext highlighter-rouge">allowJs</code> and <code class="language-plaintext highlighter-rouge">checkJs</code> to true.</p>

<p>Then you can run tsc and on the .js files that are picked up type errors will be called out.  It will show where youa re trying to assing a type that is different than a previously assigned type.</p>

<p>You can add Type to Javascript (.js) files by using JS docs syntax.  You would add a comment block similar to the one below to tell what types certain variables are.  Its a docstring for the function being defined.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
*
* @param {number} contactId
* @returns
*/
async function getContact(contactId){
    ...
}
</code></pre></div></div>

<h2 id="importing-third-party-types">Importing third-party types</h2>

<p>If typescript does not have build in support for some library you are using you need to add the type defintion.  You can write it yourself or if its an open source library add the one they provide.</p>

<p>The type definitions live in the <a href="https://github.com/definitelytypes/definitelytypes">DefinitelyTyped GitHub repo</a>.  This can hard to navigate though so you want to go to <a href="https://www.npmjs.com">NPM repository</a> and search for <code class="language-plaintext highlighter-rouge">@types package_name</code><code class="language-plaintext highlighter-rouge"> for example </code>@types jquery`</p>

<p>Copy the install command you get from NPM repository and this will add the types definition to your node modules directory.</p>

<p>Once you add it your editor (VS code) will pick it up and give you documentation and auto completion.</p>

<p>For your own libraries you would need to create your own .d.ts files to define the types.  That is a seperete course in end of itself.  You can copy and modify the public ones as a starting point.</p>

<p># Basic Typescript Usage</p>

<p>## Primatives and built-in types</p>

<p>If you just assign a variable for exmaple <code class="language-plaintext highlighter-rouge">let x = 5</code>, Typescirpt will infer the type and make it a number.  If ou want to specify what type variable should be you use the :type notation such as in the examples below.</p>

<p><code class="language-plaintext highlighter-rouge">let x: number</code>
 <code class="language-plaintext highlighter-rouge">let y: string</code>
 <code class="language-plaintext highlighter-rouge">let z: boolean</code>
 <code class="language-plaintext highlighter-rouge">let a: Date</code>
 <code class="language-plaintext highlighter-rouge">let b: string[]</code></p>

<p>If you actually want to be able to change variable types you can use the <code class="language-plaintext highlighter-rouge">any</code> type when defining the variable.</p>

<p><code class="language-plaintext highlighter-rouge">let b: any</code></p>

<p>You can also cast to any type.</p>

<p><code class="language-plaintext highlighter-rouge">b = "Hello" as any</code></p>

<p>Using any type kind of goes against using Typescript in the first place.</p>

<h2 id="creating-custom-types-with-interfaces">Creating custom types with interfaces</h2>

<p>The syntax for defining an interface is the keyword interface followed by the custom type name and the properties of the type as in the examle below…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Contact{
    id: number;
    name: string;
    birthDate: Date;
}
</code></pre></div></div>

<p>Interface are only use for Typescript type checking and are never included in your runtime code.</p>

<p>To declare a variable as a custom type you would use the following…</p>

<p><code class="language-plaintext highlighter-rouge">let primaryContact: Contact;</code></p>

<p>If a field is optional you can appen a question to the fields name as in example below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Contact{
    id: number;
    name: string;
    birthDate?: Date;
}
</code></pre></div></div>

<p>This means that you can omit the birhtDate field, but if you include it; it must be a Date type.</p>

<p>You can also you an interface inside an interface using the <code class="language-plaintext highlighter-rouge">extends</code> keyword as in the example below…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Contact extends Address{
    id: number;
    name: string;
    birthDate?: Date;
}

interface Address{
    line1: string;
    line2: string;
    province: string;
    region: string;
    postalCode: string;
}

let primaryContact = {
    birthDate: new Date("01-01-1980"),
    id: 12345,
    name: "Jamie Johnson",
    postalCode: "94044"
}
</code></pre></div></div>

<h2 id="defining-types-using-type-aliases">Defining types using type aliases</h2>

<p>Type alias just provides an alternate name to an elready existing type.  You declare the alias with the <code class="language-plaintext highlighter-rouge">type</code> keyword as in the example below..</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ContactName = string;

interface Contact extends Address{
    id: number;
    name: ContactName;
    birthDate?: Date;
}
</code></pre></div></div>

<p>Type aliases can be used interchangebly with the original type.</p>

<p>You can use them to give a little more meaning to the field you are assigning.  For example “its not just a string value, its a contact name value”.</p>

<p>It also allows you to change all the types in a single location rather then multipl locations in yoru code.</p>

<h2 id="defining-enumerable-types">Defining enumerable types</h2>

<p>Enums are a type that has a hard coded list of values and is defined like this…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum ContactStatus{
    Active,
    Inactive,
    New
}

interface Contact{
    id: number;
    name: string;
    birthDate?: Date;
    status: ContactStatus;
}

let primaryContact = {
    birthDate: new Date("01-01-1980"),
    id: 12345,
    name: "Jamie Johnson",
    status: ContactStatus.Active
}
</code></pre></div></div>

<p>enums do make it into your runtime code.</p>

<p>By defulat the Enum value will evaluate to a number (based on position in enum) if you want them to evaluate to a string value you would do the following…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum ContactStatus{
    Active = "active",
    Inactive = inactive",
    New = new
}
</code></pre></div></div>

<p>You can use any values you like as long as they are all of the same type.</p>

<h2 id="typing-functions">Typing Functions</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function clone(source: Contact): Contact{
    return Object.apply({}, source);
}
</code></pre></div></div>

<p>The argument here is type to Contact and the return value is as well.  Note that you can leave off the return type and Typescript will figure it out, but you may not get what you expect.  In this example the apply function woudl rerurn the any type, so if you don’t specify the return type it will be any in this case.</p>

<p>You can also have a function passed as a variable as in example below…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function clone(source: Contact, func: (source:Contact) =&gt; Contact): Contact{
    return Object.apply({}, source);
}
</code></pre></div></div>

<p>If you want to define a method on an interface you would…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Contact extends Address{
    id: number;
    name: ContactName;
    clone(name: string): Contact
}
</code></pre></div></div>

<h2 id="defining-a-metatype-using-generics">Defining a metatype using generics</h2>

<p>A generic type is a metatatype (a type that represents any other type you may want to substitue in)</p>

<p>For example we will use our clone function again.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function clone&lt;T&gt;(source: T): T{
    return Object.appply({}, source);
}
</code></pre></div></div>

<p>T here is just a convention.  You can use any valid type name.  What we are saying here is whatever type gets passed in, is the type that will be returned.  This is what typescript will enforce.</p>

<p>You can use multipel generic type parameters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function clone&lt;T1, T2&gt;(source: T1): T2 {
    return Object.appply({}, source);
}
</code></pre></div></div>

<p>Since in the example above Typescript cannot infer what the types are we need to specify when calling the function as in the example below…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const b = clone&lt;Contact, Contact&gt;(a)
</code></pre></div></div>

<p>Generic contraints allow you to put more restictive rules on genric type parameters.  For example if you wanted to make sure that your return type is same as the input type you would…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function clone&lt;T1, T2 extends T1&gt;(source: T1): T2{
    return Object.apply({}, source);
}
</code></pre></div></div>

<p>If you are trying ot add a constraint on something that is not defined you can inline the constaid as in …</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getNextId&lt;T extends { id: number}&gt;(items: T[]): number{
    return items.reduce((max, x) =&gt; x.id &gt; max ? max : x.id, 0) + 1
}
</code></pre></div></div>

<p>In this example whatever you apss in to the function needs to be an array of object that must have an id attribute.</p>

<p>In the above example whatever type you return (T2) must have the same fields as the input type (T1).  It does not have to extne the origin type just have same properties and add it whatever other properties it wants.</p>

<p>Generics are not limited to functions they can be used in interfaces and classes as well.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface UserContact&lt;TExternalId&gt;{
    id: number,
    name: string,
    username: string,
    externalId: TExternalId,
    loadExternalId(): Task&lt;TexternalId&gt;
}
</code></pre></div></div>

<h1 id="defining-more-complex-types">Defining More Complex Types</h1>

<h2 id="combining-multiple-types-with-union-types">Combining multiple types with union types</h2>

<p>If you want a field to support multiple types you would do something like the below.  Where the birthDate field can be a Date a number or a string.  You can list as many types as you wish.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Contact {
    id: number;
    name: ContactName;
    birthDate?: Date | number | string;
    status?: ContactStatus
}
</code></pre></div></div>

<p>You can also make this code a bit cleaner using type aliases as in the example below…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ContactBirthDate = Date | number | string

interface Contact {
    id: number;
    name: ContactName;
    birthDate?: ContactBirthDate;
    status?: ContactStatus
}
</code></pre></div></div>

<p>You can also use union types instead of enums for example instead of the below code…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum ContactStatus{
    Active = "active",
    Inactive = inactive",
    New = new
}
</code></pre></div></div>

<p>You can use a uniion type as in…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ContactStatus = "active" | "inactive" | "new"
</code></pre></div></div>

<p>Using this approach you no longer have to use the . notations you still write the sting but Typescript will enforce that the value is one of the allowed values.</p>

<p>You can also combine types.  In thte above example we use <code class="language-plaintext highlighter-rouge">|</code> sysmbol to pick one of the types.  You can use the <code class="language-plaintext highlighter-rouge">&amp;</code> symbol to combine types.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type AddressableContact = Contact &amp; Address
</code></pre></div></div>

<p>This will create a tpe that has the fields of Contact and Address combined.</p>

<h2 id="keyof-operator">Keyof operator</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ContactFields = keyof Contact

const field: ContactFields = "birthDate"
</code></pre></div></div>

<p>The above line means that the values of a variable of type ContactField can only contains values that are keys of the Contact type.  If you add a field to Contact the allowed values for ContactFields will be updated.  This is not compiled into runtime.</p>

<p>A real world use of this is for example writing a function that takes an opbect an an attribute of that object as in the example below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getValue&lt;T&gt;(source: T, propertyName: keyof T){
    return source[propertyName]
}
</code></pre></div></div>

<p>You can pass in any object and Typescript will know to limit you to only keys of that object for the propertyName argument.</p>

<p>A cleaner version of this function is below.  Here you are interoducing a second generic type that can be used elsewhere in the function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getValue&lt;T, U extends keyof T&gt;(source: T, propertyName U){
    return source[propertyName]
}
</code></pre></div></div>

<h2 id="typeof-operator">Typeof operator</h2>

<p>Typeof operator exists in Javascript, but you can make it work with Tpescript.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function toContact(nameOrContact: string | Contact): Contact {
    if (typeof nameOrContact === "object){
        return {
            id: nameOrContact.id,
            name: nameOrContact.name,
            status: nameOrContact.status
        }
    }
    else {
        return {
            id: 0,
            name: nameOrContact,
            status: "active"
        }
    }
}
</code></pre></div></div>

<p>In the code above we are using union operator to limit input to a string or Contact type.</p>

<p>You can also use the typeof operator to avoid declaring a type explicitly.  For exmaple…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const myVar = { min: 1, max: 200 }

function save(source: typeof myVar) {...}
</code></pre></div></div>

<p>With the above code Typescript during compilation will enforc that the type you pass in to function matches the type of myVar.</p>

<h2 id="indexes-access-types">Indexes access types</h2>

<p>You can use an index into an object to define a type.  For example…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Awesome = Contact["id]

interface ContactEvent {
    contactId: Contact["id]
}
</code></pre></div></div>

<p>fist line in exmample above is just showing how that is used on its own.  The second part of an example show how you can use this in an custom type (defined with interface keyword) to show the intention of what the contactId type should be.</p>

<p>Below is a more advance example…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function handleEvent&lt;T extends keyof ContactEvents&gt;(
    eventName: T, 
    handler: (evt: ContactEvents[T]) =&gt; void
    ){
        if (evnetName === "statusChanged"){
            handler({ contactId: 1, oldStatus: "active", newStatus: "inactive"})
        }
}
</code></pre></div></div>

<p>In the example above we have the type T and keys of that type being used as arguments to the function.  Just a neat way of using this syntax.</p>

<h2 id="defining-dynamic-but-limited-types-with-records">Defining Dynamic but limited types with records</h2>

<p>Record type lets yo udefine some structure and typing without having to detail every possible property.  If you find yourself wanting to use any type you should probably look into Record as a work aournd.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x: Record&lt;string, string&gt; = { name: "Bruce Wayne" }
</code></pre></div></div>

<p>The above line syas that you can have an object whose names and propery are strings.</p>

<p>If you need to be more flexible you can have the names be strings, but the values be vaiours types as in the exampe below…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x: Record&lt;string, string | number | boolean | Function&gt; = { name: "Bruce Wayne"}
x.number = 1234
x.active = true
x.log = () =&gt; console.log("awesome")
x = 1234 # this will be a violation.
</code></pre></div></div>

<p>As mentioned above you can also do this with the attribut names as in the example below…</p>

<p>function searchContacts(contacts: Contact[], query: Record&lt;keyof Contact, Query&gt;){
    …
}</p>

<p>Here we are saing that the query objects can only have parameters which are keys of Contact and Typescript will check this for us.</p>

<h1 id="extending-and-extracing-metadata-from-existing-types">Extending and Extracing Metadata from Existing Types</h1>

<h2 id="extending-and-modifying-existing-types">Extending and modifying existing types</h2>

<p>You may have a scenario where you are trying to use a Type but not specify all of the attributes of the type as in the example below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ContactQuery = Record&lt;keyof Contact, Query&gt;

function searchContacts(contacts: Contact[], query: ContactQuery){
    return contacts.filer(contact =&gt; {
        for (const property of Object.keys(contact) as (keyof Contact)[]){
            // get the query object for this property
            const propertyQuery = query[property];
            // check to see if it matches
            if (propertyQuery &amp;&amp; propertyQuery.matches(contact[property])) {
                return true
            }
        }

        return false;
    })
}

const filteredContacts = searchContacts(
    [/* contacts */],
    {
        id: { matches: (id) =&gt; id === 123},
        name: { matches: (name) =&gt; name === "Carol Weaver" },  ### Not valid Typescript unless you do the Partial type as in example below...
    }
);
</code></pre></div></div>

<p>In above the object being passed to searchContacts will throw Typescipt error asking for all the fields.  To only use partial field use the <code class="language-plaintext highlighter-rouge">Partial</code> utility type.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ContactQuery = Partial&lt;Record&lt;keyof Contact, Query&gt;&gt;
</code></pre></div></div>

<p>Partial looks exactly like the type it wraps but all attributes are optional.</p>

<p>If you want the opposite of partial and want to restirct usage of certain properties (for example if you don’t want to allow queries on the address properties of Contact class) use the <code class="language-plaintext highlighter-rouge">Omit</code> utility class.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ContactQuery = Omit&lt;
    Partial&lt;
        Record&lt;keyof Contact, Query&gt;
    &gt;, "address" | "status"
&gt;
</code></pre></div></div>

<p>If you want to not omit but limit to only a list of properties you would use the <code class="language-plaintext highlighter-rouge">Pick</code> utility class.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ContactQuery = 
    Partial&lt;
        Pick&lt;
            Record&lt;keyof Contact, Query&gt;,
            "id" | "name"
        &gt;
    &gt;
</code></pre></div></div>

<p>With this you will only be able to access “id” and “name” properties.</p>

<p>The last utiltiy type is the <code class="language-plaintext highlighter-rouge">Required</code> which turns all properties to required instead of optional.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type RequiredContactQuery = Required&lt;ContactQuery&gt;
</code></pre></div></div>

<h2 id="extracting-metadata-from-existing-types">Extracting metadata from existing types</h2>


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My References</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My References</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
