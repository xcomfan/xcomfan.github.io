---
layout: page
title: "Raw Notes"
permalink: /gitref/rawnotes/
---

[comment]: <> (TODO: REV MARKER)

## Git Internals

### Git Internals - Plumbing and Porcelain

[comment]: <> (TODO: go though with a .git directory and see all this in action)

Below is what a freshly `git init` directory looks like.

```
$ ls -F1
config
description
HEAD
hooks/
info/
objects/
refs/
```

* `description` file is used only by the GitWeb program so we don't cover it.
* `config` file contains your project-specific options
* `info` directory keeps a global exclude file for ignored patterns that you don't want to track in a .gitignore file.
[comment]: <> (TODO: Link to hooks section here once you write that up.)
* `hooks` directory contains your client or server hook scripts.

The 4 we don't see yet and will cover later are

* `index` file where Git stores your staging area information.
* `objects` directory which stores all the content for your database
* `refs` directory which stores pointers into commit objects in the objects directory (branches, tags, remotes, etc.)
* `HEAD` file which points to the branch you currently have check out

### Git Internals - Git Objects

Git is a content addressable filesystem.  This means that at its core Git is a key value store.  You can insert any content into a Git repository and Git will hand you back a unique key which you can later use to retrieve that content.

The book goes though an example where the `git hash-object` command is used to store a file in the `objects` directory.  The key take away from this example is that if you have a file test.txt and use git hash-object to store it, each time you call git hash-object and pass it text.txt a new object is stored in the objects directory with the hash generated by the contents of the file.  In the object directory the hash is the filename for the content as it was when git hash-object is used.  The hashed stored object is called a `blob`.

#### Tree Objects

The **tree** object is used in Git internals to store the file name and allow you to store a group of files together.

In Git internals everything as stored as tree and blob objects with trees corresponding to UNIX directory entries and blobs corresponding more or less to inode or file contents.

A single tree object contains one or more entries, each of which is the SHA-1 hash of a blob or subtree with its associated mode, type, and filename.

Git normally creates a tree by taking the state of your staging area or index and writing a series of tree objects from it.

#### Commit Objects

The tree object essentially stores a snapshot, but we don't have an easy way of referencing that snapshot (SHA-1 values are hard to remember) and we have no information about the snapshot (who saved it or when they saved it).  This is the information that the commit object stores for you.

A commit object stores the top level tree for the snapshot of the project at that point, the parent commits if any, the author/committer information, a timestamp, and after a blank line the commit message.

The stored objects, tree objects and commit objects make up the history you see when you use the `git log` command.  This is essentially what Git does when you run the git add and git commit commands — it stores blobs for the files that have changed, updates the index, writes out trees, and writes commit objects that reference the top-level trees and the commits that came immediately before them.

#### Object Storage

There is a header stored with every object you commit to your Git object database.  This header stores the type of object (blob or tree), the size in bytes of the content and a null byte at the end.

Git concatenates the header and the original content and then calculates the SHA-1 checksum of that new content.  Git compresses the new content with zlib and writes the zlib-deflated content to an object on disk.  The file is stored in objects directory with first 2 chars of the sha1 being the subdirectory and the remaining 38 the filename.  All Git objects are stored this way.

## Git Internals - Git References

Within the .git directory there is a refs directory.  This directory contains files which store the SHA-1 for the commits in your projects that are the HEADs for your local and remote branches.  For example the HEAD file you see in your .git directory refers to .git/refs/heads/main if you are on the main branch.

```
$ cat HEAD
ref: refs/heads/main
```

When you are in a detached head state (if you check out a tag, commit or remote branch) the value in the HEAD file will be a specific SHA-1 of a commit.

### Tags

In addition to blobs, trees and commits; tags are the fourth object type in Git.  Like the commit objects, a tag contains a tagger, a date, a message, and a pointer.  The main difference is that a tag object generally points to a commit object instead of a tree.  Its like a branch reference but it never moves.  It always points to the same commit but gives it a friendlier name.

### Remotes

The third type of reference is the remote reference.  If you add a remote and push to it, Git stores the commit SHA-1 value you last pushed to that remote for each branch in the refs/remotes directory.

Remote references are considered read only.  You can git checkout one, but Git won't symbolically reference HEAD to one so you will never update it with a commit.  Git manages them as bookmarks of the last known state of where those branches were on those servers.

## Git Internals - Packfiles

Packfiles are the Git mechanism for organizing files in stored in your commits to save disk space.  Instead of storing the copy of the file in each commit, packed files store and organize the deltas between those files.

## Git Internals - Transfer Protocols

Git can transfer data between two repositories via a dumb protocol or a smart one.  The dump protocol is used if you are setting up a read only repository to be read only over HTTP via GET requests.  The smart protocol needs Git code running on the server.  It can figure out what the client has and needs and generate the packfile for that request.

## Git Internals - Maintenance and Data Recovery

### Maintenance

Git periodically runs the git auto gc (garbage collection) call which you can trigger manually by running `git gc --auto`.  This usually does nothing as you need to have 7K loose files or more than 50 packfiles before this command takes action.  These limits can be adjusted via the `gc.auto` and `gc.autopacklimit` configuration settings.  When this call does act it will place the loose files into a packfile and consolidate the packfiles into one big packfile.  It also removes objects that are not accessible from any commit and are a few months old.

### Data Recovery

If you force delete a branch that had work in it, or you hard reset a branch abandoning the commits there you may be able to recover the work.

For example in the below scenario...

```
$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b Modify repo.rb a bit
484a59275031909e19aadb7c92262719cfcdf19a Create repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
```

If you run the command `git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9`  You effectively loose the top two commits.  See blow...

```
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
```

One way to get your lost work back is via the `reflog` command.  

[comment]: <> (TODO: We covered reflog in earlier notes makes the link here.  I should break out the content here into a data recover section and have each scenario plus recovery steps listed.)

When you run `git reflog` it will show you the history of where you have been as in the example below.

```
$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: Modify repo.rb a bit
484a592 HEAD@{2}: commit: Create repo.rb
```

You can use the git log format on your reflog data by using the -g argument on git log.

`git log -g`

Once you identify the commit you lost you can create a new branch from that commit with the command below.  This will give you a new branch named recover-branch which will be where your master branch used to be making the lost commits reachable again.

`git branch recover-branch ab1afef`

If for some reason you don't have the lost work in your reflog history.  You can try using the git fsck utility.  

`git fsck --full`

When run with full option git fsck will show you all of the commits that are not reachable.  You can identify your lost commit from that output and create a branch from it as you did above.

[comment]: <> (TODO: Book glosses over the way you identify the commit you want to go to so you may want to run though the exercise in the book to get a better idea.)

### Removing Objects

This is useful if someone committed a large binary file to your repo. 

***This technique is destructive to the commit history***  It rewrites every commit object sine the earliest tree y ou have to modify to remove a large file reference.  If you do this when users have based their work on the commit you have to notify all users to rebase their work onto your new commits.

[comment]: <> (TODO: Should run though this exercise as well)

Kind of a side note but you can use the below command to see how much space your repo is using.

To find the large file you can use the Git plumbing command git verify-pack and sort ont he third field

`git verify-pack -v .git/objects/pack/pack-29…69.idx | sort -k 3 -n | tail -3`

Once you find the commit with the large file you can use rev-list command to find the file itself.

`git rev-list --objects --all | grep 82c99a3`

Now you need to remove this file from all trees in your past.  You can see what commits modified this file with the command...

`git log --oneline --branches -- git.tgz`

Based on our example you must rewrite all commits downstream from 7b30847.  To do this we use filter-branch command.

[comment]: <> (TODO: I have this command elsewhere in notes need to make the link.)

```
$ git filter-branch --index-filter \
  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten
```

The --index-filter option is similar to the --tree-filter option used in Rewriting History except that instead of passing a command that modifies the files checkout on disk you are modifying your staging area or index each time.

Rather than remove a specific file with `rm file` you have to remove it with git rm -- cached.  You must remove it from the index, not from disk.  The reason to do it this way is speed because Git doesn't have to check out each revision to disk before running your filter, the process can be much much faster.

The --ignore-unmatch option to git rm tells it not to error out if the pattern you’re trying to remove isn’t there. Finally, you ask filter-branch to rewrite your history only from the 7b30847 commit up, because you know that is where this problem started. Otherwise, it will start from the beginning and will unnecessarily take longer.

Your history no longer contains a reference to that file. However, your reflog and a new set of refs that Git added when you did the filter-branch under .git/refs/original still do, so you have to remove them and then repack the database. You need to get rid of anything that has a pointer to those old commits before you repack:

```
$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)
```

You can see from the size value that the big object is still in your loose objects, so it’s not gone; but it won’t be transferred on a push or subsequent clone, which is what is important. If you really wanted to, you could remove the object completely by running git prune with the --expire option:

```
$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
```

## Git Internals - Environment Variables

Git always runs inside a bash shell and uses environment variables to determine how it behaves.  Below are the most useful environment variables.

### Global behavior environment variables

**GIT_EXEC_PATH** - determines where Git looks for its sub-programs such as git-commit, git-diff etc.  You can check the current setting with the command `git --exec-path`

**HOME** - Not usually customized as many things depend on it.  This variable is where Git looks for the global config file.

**PREFIX** - Similar to the HOME variable but for system-wide configuration file.

**GIT_CONFIG_NOSYSTEM** - if set, disabled use of the system wide configuration file.  This is useful if your system config is interfering with your commands, but you don't have access to change or remove it.

**GIT_PAGER** - controls the program used to display multi-page output on the command line.  If this is not set PAGER will be used as the fallback.

**GIT_EDITOR** - The editor Git will launch when the user needs to edit text.  In a commit for example.

### Repository location environment variables

**GIT_DIR** - The location of the .git folder.  If this directory is not specified Git will walk up directory tree till it finds or gets to ~ or / directories.

**GIT_CEILING_DIRECTORY** - Controls the behavior of searching for a .git directory.  If you have some slow loading directories such as a tape drive you may want to prevent Git from searching those directories.

**GIT_ALTERNATE_OBJECTS_DIRECTORIES** - Is a colon separated list which tells Git where to check for objects if they are not in GIT_OBJECT_DIRECTORY.  If you have a lot of projects with large files that have the exact same contents, this can be used to avoid storing too many copies of them.

### Pathspec environment variables

A "pathspec" refers to how you specify paths to things in Git, including the use of wildcards.  These are used in the .gitignore file as well as in command lines such as git add *.c.

[comment]: <> (TODO: Add the above to your definition list.)

**GIT_GLOB_PATHSPECS and GIT_NOGLOB_PATHSPECS** - control the default behavior of wildcards in pathspecs.  If GIT_GLOB_PATHSPECS is set to 1, wildcard characters act as wildcards (which is the default); if GIT_NOGLOB_PATHSPECS is set to 1, wildcard characters only match themselves, meaning something like *.c would only match a file named “\*.c”, rather than any file whose name ends with .c. You can override this in individual cases by starting the pathspec with :(glob) or :(literal), as in :(glob)\*.c.

**GIT_LITERAL_PATHSPECS** - Makes it so that no wildcard expansion works and override prefixes are disabled as well.

**GIT_ICASE_PATHSPECS** - sets all pathspecs tow ork in a case-insensitive manner.

### Committing environment variables

The final creation of a Git commit object is usually done by git-commit-tree which uses the following environment variables falling back on config values if not set.

**GIT_AUTHOR_NAME** - Human readable name in the "author" field

**GIT_AUTHOR_DATE** is the timestamp used for the “author” field.

**GIT_COMMITTER_NAME** sets the human name for the “committer” field.

**GIT_COMMITTER_EMAIL** is the email address for the “committer” field.

**GIT_COMMITTER_DATE** is used for the timestamp in the “committer” field.

**EMAIL** is the fallback email address in case the user.email configuration value isn’t set. If this isn’t set, Git falls back to the system user and host names.

### Networking environment variables

**GIT_CURL_VERBOSE** - Git uses curl library to do network operations over HTTP.  This setting tells Git to emit all the messages generated by that library similar to `curl -v`

**GIT_SSL_NO_VERIFY** - Tells Git not to verify SSL certificates.

### Diffing and merging environment variables

**GIT_DIFF_OPTS** - The only valid values are `-u<n>` or `--unified=<n>`, which controls the number of context lines shown in a git diff command.

**GIT_MERGE_VERBOSITY** - controls the output for the recursive merge strategy. The allowed values are as follows:
* 0 outputs nothing, except possibly a single error message.
* 1 shows only conflicts.
* 2 also shows file changes.
* 3 shows when files are skipped because they haven’t changed.
* 4 shows all paths as they are processed.
* 5 and above show detailed debugging information.

The default value is 2