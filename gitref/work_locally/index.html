<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Working on your code | My References</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Working on your code" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<link rel="canonical" href="https://xcomfan.github.io/gitref/work_locally/" />
<meta property="og:url" content="https://xcomfan.github.io/gitref/work_locally/" />
<meta property="og:site_name" content="My References" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Working on your code" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","headline":"Working on your code","url":"https://xcomfan.github.io/gitref/work_locally/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://xcomfan.github.io/feed.xml" title="My References" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My References</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Working on your code</h1>
  </header>

  <div class="post-content">
    
<h2 id="the-3-states-of-your-files-in-git">The 3 states of your files in Git</h2>

<p>As you are working locally the files in your working directory can be in one of the 3 states below.</p>

<table>
  <thead>
    <tr>
      <th>State</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>modified</td>
      <td>You have changed the file, but have not yet committed it to the database</td>
    </tr>
    <tr>
      <td>staged</td>
      <td>You have marked a file in its current version to go into your next commit snapshot</td>
    </tr>
    <tr>
      <td>committed</td>
      <td>The file state is safely stored in your Git database</td>
    </tr>
  </tbody>
</table>

<h2 id="viewing-the-status-of-your-working-tree">Viewing the status of your working tree</h2>

<p><code class="language-plaintext highlighter-rouge">git status</code></p>

<p>This command will display the following details</p>

<table>
  <thead>
    <tr>
      <th>Section</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“On branch”</td>
      <td>Branch you are currently on TODO: Link to Branching section once you have it.  Probably need to rephrase “working on”</td>
    </tr>
    <tr>
      <td>“No commits yet”</td>
      <td>Only displayed if repository has no commits/history</td>
    </tr>
    <tr>
      <td>“Changes to be committed”</td>
      <td>The staged changes that will be committed when you run the <code class="language-plaintext highlighter-rouge">git commit</code> command</td>
    </tr>
    <tr>
      <td>“Changes not staged for commit”</td>
      <td>Modified files in your working copy that are not staged to be committed</td>
    </tr>
    <tr>
      <td>“Untracked Files”</td>
      <td>Files in your working copy that Git is not tracking</td>
    </tr>
  </tbody>
</table>

<h2 id="recording-changes-in-your-working-tree">Recording Changes In Your Working Tree</h2>

<h3 id="stage-new-files-or-changes-to-tracked-files">Stage new files or changes to tracked files</h3>

<p><strong>Add (stage) a single file</strong></p>

<p><code class="language-plaintext highlighter-rouge">git add somefile.txt</code></p>

<p><strong>Add all modified and new files</strong></p>

<p><code class="language-plaintext highlighter-rouge">git add .</code></p>

<p><strong>You can also add with globing</strong></p>

<p><code class="language-plaintext highlighter-rouge">git add *.py</code></p>

<p><strong><em>Note:</em></strong> Git stages files exactly as they are at the moment of staging.  This means that if you <code class="language-plaintext highlighter-rouge">git add</code> a file and then modify it you will see it in both “Changes to be committed” and “Changes not staged for commit” sections when you run the <code class="language-plaintext highlighter-rouge">git status</code> command.</p>

<h3 id="interactive-staging">Interactive staging</h3>

<p>Interactive staging is useful if you want to stage parts of files to make a more logical commit.</p>

<p>To use interactive staging use the -i or –interactive arguments to git add.</p>

<p><code class="language-plaintext highlighter-rouge">git add -i</code></p>

<p>Once you run this command you will get an interactive prompt which will allow you to choose what you want to add to the commit.</p>

<ul>
  <li>Use the <strong>update</strong> option if you want to stage an entire file.</li>
  <li>Use the <strong>patch</strong> option if you want to pick portions of a file to stage.</li>
</ul>

<p>When you pick the patch option you will be presented with hunks of a file and given the ability to stage the hunk not stage it or to split it into smaller hunks or to manually edit the hunk.</p>

<p>When using the edit option to edit a hunk of file to not include a removed line change the - to a space.  To remove an added line from the commit just delete it in the interactive editor.</p>

<p>After you exit the interactive staging you can run <code class="language-plaintext highlighter-rouge">git commit</code> to make your commit.</p>

<h3 id="un-stage-a-file">Un-stage a file</h3>

<p><strong>If you staged a file by mistake you can un-stage it with the command</strong></p>

<p><code class="language-plaintext highlighter-rouge">git restore --staged myfile.txt</code></p>

<p>If on Git version older than 2.23.0 use the below command also works.</p>

<p><code class="language-plaintext highlighter-rouge">git reset HEAD filename.xyz</code></p>

<h3 id="un-modifying-a-modified-file">Un-modifying a modified File</h3>

<p>If you want to undo the changes you made to a tracked file use the command below.</p>

<p><strong><em>WARNING</em></strong> <em>This is a dangerous command.  Git will replace the specified files width he last <strong>staged or committed</strong> version.  Any changes you made to the file will be gone</em>  If you wish to keep the changes made to the file but get it out of the way temporarily you can stash it.</p>

<p><code class="language-plaintext highlighter-rouge">git checkout filename.xyz</code> or <code class="language-plaintext highlighter-rouge">git restore filename.xyz</code> if on Git version 2.23.0 or newer.</p>

<h2 id="searching-in-your-work">Searching in your work</h2>

<p>Git ships with a built in grep that allows you to search though any <a href="/gitref/definitions/#committed-tree">committed tree</a>, or the index for a string of regular expressions.  The benefit of git grep over regular grep is that its faster and you can search through any <a href="/gitref/definitions/#tree">tree</a> in Git not just the working directory.</p>

<p>By default git grep will look through files in your local directory.</p>

<p><strong>You can use the -n or –line-number option to print out the line numbers where Git has found matches.</strong></p>

<p><code class="language-plaintext highlighter-rouge">git grep -n my_magic_function</code> or <code class="language-plaintext highlighter-rouge">git grep --line-number my_magic_function</code></p>

<p>There are many options to git grep.  See <code class="language-plaintext highlighter-rouge">man git grep</code> for what’s available.</p>

<p><strong>You can use -c or –count to get the file names and found instance counts.</strong></p>

<p><code class="language-plaintext highlighter-rouge">git grep -c TODO</code> or <code class="language-plaintext highlighter-rouge">git grep --count TODO</code></p>

<p><strong>Look for lines defining either of two options</strong></p>

<p>The example below will look for a line that has #define and either MAX_PATH or PATH_MAX.</p>

<p><code class="language-plaintext highlighter-rouge">git grep -e '#define' --and \( -e MAX_PATH -e PATH_MAX \)</code></p>

<p><strong>See the function name of the git grep match</strong></p>

<p>You can have git show you the preceding line of function matches with the -p or –show-function argument.  In other words Git Grep will look for function definition where your search matches and prints that so you know which function its in.   In example below I am searching for ‘return’ as its a good example of seeing the match and the function name.</p>

<p><code class="language-plaintext highlighter-rouge">git grep -p return *.c</code> or <code class="language-plaintext highlighter-rouge">git grep --show-function return *.c</code></p>

<p>You can search for complex combinations of strings with the –and flag, which ensures that multiple matches must occur in the same line of text.</p>

<p><strong>Exclude a directory from your search</strong></p>

<p>The example below looks for solution, excluding files in Documentation.</p>

<p><code class="language-plaintext highlighter-rouge">git grep solution -- :^Documentation</code></p>

<p><strong>search for lines with values in a file that has all the listed values</strong></p>

<p>The example below looks for a line that has NODE or Unexpected in files that have lines that match both.
<code class="language-plaintext highlighter-rouge">git grep --all-match -e NODE -e Unexpected</code></p>

<p><strong>search older version of code using a tag</strong></p>

<p>The example below will search for lines that define a constant whose name contains either of the substrings LINK or BUF_MAX specifically in an older version of the codebase by specifying the tag v1.8.0</p>

<p><code class="language-plaintext highlighter-rouge">git grep --break --heading -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0</code></p>

<ul>
  <li>
    <p>–break argument will print empty lines between matches from different files</p>
  </li>
  <li>
    <p>–heading argument will show the file name above the matches</p>
  </li>
  <li>
    <p>-n or –line-number will add line numbers to output</p>
  </li>
  <li>
    <p>-e argument specified that the next parameter in command is the pattern.</p>
  </li>
</ul>

<h2 id="cleaning-your-working-directory">Cleaning your working directory</h2>

<p>The git clean command is useful for removing untracked files from your working directory.  <strong><em>Note:</em></strong> files removed with this command cannot be retrieved.</p>

<p>To remove any untracked files and also any subdirectories that become empty use the command</p>

<p><code class="language-plaintext highlighter-rouge">git clean -f -d</code></p>

<p>The -f option is the force option and -d will make it recourse.</p>

<p>By default git clean will not operate on files that are in teh .gitingore file.  You can use the -x option to have it remove those files as well.  This is useful for removing build artifacts in a script.</p>

<h2 id="working-with-git-reset">Working with git reset</h2>

<h3 id="git-concepts-to-help-understand-git-reset-command">Git concepts to help understand git reset command</h3>

<h4 id="the-three-trees">The three trees</h4>

<p>An easier way to think about rest and checkout is though the mental model of Git managing three different trees.  Trees here refer to a collection of files not the data structure.</p>

<h5 id="the-head">The HEAD</h5>

<ul>
  <li>The HEAD “tree” is the last commit snapshot and the next parent.</li>
  <li>HEAD is the pointer to the current branch reference, which is in turn a pointer to the last commit made on that branch.</li>
  <li>You can think of HEAD as the snapshot of your last commit on your current branch</li>
</ul>

<h5 id="the-index">The Index</h5>

<ul>
  <li>The index is your proposed next commit.  Its also referred to as the “staging area”</li>
  <li>The index is what Git looks at when your run the git commit command.</li>
  <li>Git populates the index with a list of all the file contents that were last checked out into your working directory and what they looked like when they were originally checked out.
    <ul>
      <li>You then replace some of these files with new versions and the git commit command converts them into a new commit.</li>
    </ul>
  </li>
</ul>

<h5 id="the-working-directory">The working directory</h5>

<ul>
  <li>Think of the working directory as a sandbox where you can try changes before committing them to the index/staging area.</li>
  <li>The other two trees store their content in an efficient, but inconvenient manner.  The working tree unpacks them into actual files making them easier to edit.</li>
  <li>Working directory is commonly called the “working tree”</li>
</ul>

<h5 id="git-workflow-of-the-three-trees">Git workflow of the “three trees”</h5>

<p>Gits typical workflow is to record snapshots of your project in successively better states, by manipulating the states of the three trees.</p>

<p>Lets say we start with a new directory which is not yet a Git repository with a single file in it.  If we run the <code class="language-plaintext highlighter-rouge">git init</code> command this will create a Git repository with a <strong>HEAD</strong> references pointing to the unborn <em>master</em> branch.  At this point only the <strong>working directory</strong> has any content.</p>

<p>Now we want to commit our single file, so we use the <code class="language-plaintext highlighter-rouge">git add</code> command.  This will take the content in our <strong>working directory</strong> and copy it to the <strong>index</strong>.</p>

<p>We then run <code class="language-plaintext highlighter-rouge">git commit</code>, which takes the contents of the <strong>index</strong> and saves it as a permanent snapshot, creates a commit object which points to that snapshot, and updates <em>master</em> to point to that commit.  At this point if you run <code class="language-plaintext highlighter-rouge">git status</code> you will see no change because all three trees are the same.</p>

<p>Switching  branches or cloning goes though a similar process. When you checkout a branch, it changes <strong>HEAD</strong> to point to the new branch ref, populates your <strong>index</strong> with the snapshot of that commit, then copies the contents of the <strong>index</strong> into your <strong>working directory</strong>.</p>

<h3 id="the-role-of-the-reset">The role of the reset</h3>

<p>When you run the <code class="language-plaintext highlighter-rouge">git reset</code> command, Git manipulates the three trees doing  up to three operations depending on the options specified.</p>

<h4 id="step-1-move-the-head-soft">Step 1: Move the HEAD (–soft)</h4>

<p>The first thing reset will do is move what <strong>HEAD</strong> points to.  This is not the same as changing HEAD itself (which is what checkout does); reset moves the branch that <strong>HEAD</strong> is pointing to.</p>

<p>All calls to git reset have this as the first step.  If you specify the –soft argument, git reset will stop here.  This essentially undoes the last commit.    At this stage if you run <code class="language-plaintext highlighter-rouge">git commit</code>, Git creates a new commit and moves the branch that HEAD points to up to it.  When you reset back to HEAD~ (the parent of HEAD), you are moving the branch back to where it was, without changing the index or working directory (The working directory and index stay the same, but you won’t see the previous commit in <code class="language-plaintext highlighter-rouge">git log</code>).</p>

<p>At this point you can run <code class="language-plaintext highlighter-rouge">git commit</code> again to accomplish what <code class="language-plaintext highlighter-rouge">git commit --amend</code> would have done.</p>

<h4 id="step-2-updating-the-index-mixed">Step 2: Updating the index (–mixed)</h4>

<p>Step two is the default for git reset.  If you run git reset without any argument it will stop at this step 2.  In step 2 reset will update the index with the contents of whatever snapshot HEAD points to.  The –mixed argument is optional.</p>

<p>At this step your last commit is still undone, but it will also un-stage everything. In other words <code class="language-plaintext highlighter-rouge">git reset HEAD~</code> will undo your last commit and add commands.</p>

<h4 id="step-3-updating-the-working-directory-hard">Step 3: Updating the working directory (–hard)</h4>

<p>The third ting that reset will do (if you specify the –hard) option is to make the working directory look like the index.</p>

<p>In other words git <code class="language-plaintext highlighter-rouge">reset --hard HEAD~</code> will undo the git commit command your for your prior commit, the git add command for your prior commit, and eliminate any changes you made to the files in your working directory.</p>

<h3 id="git-reset-with-a-path">Git reset with a path</h3>

<p>You can also provide git reset with a path to act on.</p>

<p>If you specify a path, reset will skip step 1 and limit the remainder of its actions to a specific file or set of files.  This makes sense because HEAD is a pointer and you can’t point to a part of a commit, but index and working directory can be partially updated.</p>

<p>If you run the command <code class="language-plaintext highlighter-rouge">git reset file.txt</code> (this command is essentially a short hand for <code class="language-plaintext highlighter-rouge">git reset --mixed file.txt</code>) git reset will</p>

<ol>
  <li>skip moving the branch HEAD points to</li>
  <li>make the index look like HEAD</li>
</ol>

<p>In other words it copies file.txt from HEAD to index.  This has the practical effect of unstaging the file.</p>

<p>You don’t have to pull the file from HEAD you can specify the commit to pull that version from.  <code class="language-plaintext highlighter-rouge">git reset eb43b4 file.txt</code></p>

<p>You can use the –patch option with git reset to un-stage content on a hunk by hunk basis.</p>

<h3 id="using-git-reset-for-squashing">Using git reset for squashing</h3>

<p>Lets say you have a project where…</p>

<ul>
  <li>The first commit has one file.</li>
  <li>The second commit added a new file and changed the first.</li>
  <li>The third commit changed the first file again.</li>
</ul>

<p>If the second commit was a work in progress and you want to squash it down you can…</p>

<p>run the command <code class="language-plaintext highlighter-rouge">git reset --soft HEAD~2</code> to move the HEAD branch back to an older commit (the most recent commit you want to keep)</p>

<p>then simply runt <code class="language-plaintext highlighter-rouge">git commit</code> again.</p>

<p>This would remove the second commit from your reachable history (the history you would push)</p>

<h2 id="reset-versus-checkout">Reset versus checkout</h2>

<h3 id="without-path-specified">Without path specified</h3>

<p>Running <code class="language-plaintext highlighter-rouge">git checkout [branch]</code> is pretty similar to running <code class="language-plaintext highlighter-rouge">git reset --hard [branch]</code> in that it updates all 3 trees for you to look like <code class="language-plaintext highlighter-rouge">[branch]</code>.</p>

<p>There are two important differences however.</p>

<ol>
  <li>
    <p>Unlike <code class="language-plaintext highlighter-rouge">reset --hard</code>, <code class="language-plaintext highlighter-rouge">checkout</code> is working directory safe.  It will check to make sure its not blowing away files that have changes to them.  It actually tries to do a trivial merge in the working directory os all the files you have not changed will be updated.  <code class="language-plaintext highlighter-rouge">reset hard</code> on the other hand, will simply replace everything across the board without checking.</p>
  </li>
  <li>
    <p>The way HEAD is updated is different.  <code class="language-plaintext highlighter-rouge">reset</code> will move the branch that HEAD points to, <code class="language-plaintext highlighter-rouge">checkout</code> will move HEAD itself to point to another branch.  So for instance if we have master and develop branches which point to different commits, and we are currently on the develop branch (so HEAD points to it).  If we run <code class="language-plaintext highlighter-rouge">git reset master</code>, develop itself will now point to the same commit that master does.  If we instead run <code class="language-plaintext highlighter-rouge">git checkout master</code> develop does not move, HEAD itself does.  HEAD will now point to master.  In both cases we are moving HEAD to point to commit A, but how we do so is very different.  <code class="language-plaintext highlighter-rouge">reset</code> moves the branch HEAD points to, <code class="language-plaintext highlighter-rouge">checkout</code> moves HEAD itself.</p>
  </li>
</ol>

<h3 id="with-path-specified">With path specified</h3>

<p>If you run <code class="language-plaintext highlighter-rouge">checkout</code> with a file path.  Like <code class="language-plaintext highlighter-rouge">reset</code> this does not move HEAD.  <code class="language-plaintext highlighter-rouge">checkout</code> will update the index with that file at that commit, but it will also overwrite the file in the working directory.</p>

<p>You can use the –patch option with checkout to select hunks you wish to check out.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My References</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My References</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
