---
layout: page
title: "Committing Your Changes"
permalink: /gitref/commit/
---

[comment]: <> (TODO: REV MARKER)

## Basic Commit

Use default editor to write your commit message (Git will bring up the editor when you run the command).

[comment]: <> (TODO: Add link to config section where you specify what editor to use)

[comment]: <> (TODO: Add how to undo a commit completely if you made one by mistake.)

`git commit`

Commit and comment in single command.

`git commit -m "My commit message"`

**Good Commit Messages**

[comment]: <> (TODO: Add what is a good commit message content here)

## Updating (amending) a Commit

If you mess up a commit and want to change or add a file use `git commit --amend` as in the example below.  Your configured editor will pop up to allow you to modify the commit message.

```
git commit -m 'My commit message'
git add forgotten_or_updated_file
git commit --amend
```

***WARNING:*** *Only amend commits that are in your local repository and have not been pushed to a remote repository.  Amending previously pushed commits and force pushing the branch will cause problems for your collaborators.*

[comment]: <> (TODO: Need a link here to the remote workflow sections.)

## Rewriting commit history

### Interactive rebase

[comment]: <> (TODO: Write up how to use interactive rebase here so the section below can just cover the specific actions?)

If your want practice with interactive rebase go to [git-rebase.io](https://git-rebase.io)

### Changing the last commit

If you just want to change your commit message (in your local working directory) the command below will bring up the editor for you to do so if you have no changes staged.

`git commit --amend`

If you have changes staged, the command above will modify your last commit again in your local working directory with the staged changes and allow you to modify your commit message.

If you want to modify the code of your last commit with the staged changes, but not the commit message use the command

`git commit --amend --no-edit`

***Note:*** Amending a commit changes the SHA-1 of the commit.  **DO NOT AMEND YOUR LAST COMMIT IF YOU ALREADY PUSHED IT.**

### Squashing Commits

You can use the interactive rebase to take a series of commits and squash them into a single commit.

First run the rebase command to go back the desired amount of commits

`git rebase -i HEAD~3`

In the interactive rebase editor replace the `pick` keyword with `squash` and Git will apply both that change and the change directly before it and have you merge the commit message.

[comment]: <> (TODO: Try this out and make any clarification updates also need to take the changing multiple commit below details of the step by step process and apply it here since you are placing this one first.)

### Splitting Commits

Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with.  For example if you want to split the middle commit of the three commits in the example below you can do that with the rebase -i script.

In the script generated by the `rebase -i` command change the instruction on the commit you wish to split to `edit`.

When the script drops you to the command line, you reset that commit, take the changers that have been reset, and create multiple commits out of them.  

When you save and exit the editor, Git will rewind to the parent of the fist commit in your list, apply the first commit, apply the second and drop you to the console.  Then you can do...

`git reset HEAD^` - resets the second commit (the one you want to split)

`git add README` - first of your split up changes

`git commit -m 'Update README formatting` - first of your split commits

`git add lib/simplegit.rb` - second of your split up changes

`git commit -m 'Add blame'` - second of your split up commits

`git rebase --continue` - apply the third commit from the rebase script

***Note:*** Do not do this with commits you already pushed

### Deleting a Commit

Interactive rebase can also delete a commit.  

In the script that interactive rebase has you edit, put the word drop before the commit you want to delete.

Because of the way Git builds commit objects, deleting a commit will cause the rewriting of all the commits that follow it.  The further back you go, the more commits need to be created which can cause lots of merge conflicts.  If you get partway through a change like this and want to abort you can use the command below to return your repo to its state before you attempted the rebase.

`git rebase --abort`

If you finish a rebase and decide its not what you want, you can use git reflog to recover an earlier version of your branch.

[comment]: <> (TODO: Need a link to reflog details also put this at top in section that covers how to use rebase as it applies to all these changes.?)

### Changing multiple commit messages

Git does not have a modify history tool, but you can use the rebase tool to rebase a series of commits onto the HEAD that they were originally based on.

With the interactive rebase tool you can stop after each commit you want to modify and change the message, add files or do whatever you wish.

For example if you want to change the last 3 commits you would use the command

`git rebase -i HEAD~3`

The -i option is for interactive rebase

***Note:*** This is a rebase command so **DO NOT** modify commits you already pushed.

Once you run the above command will bring up an editor with a list of commits you selected listed newest first. The editor shows a script the rebase will run as well as some hint information.

You need to edit this script replacing the word `pick` with `edit` on the commits you wish to stop at.

When you save and exit the editor, Git will rewind you to the last commit in the list and drops you at the command line with some hint information displayed.

As the hint says, you can now use `git commit --amend` to modify the commit you landed on or `git rebase --continue` to move on to the next commit you marked with the `edit` word in the script.

Once you are done modifying all the selected commits you will have a rewritten history.

### Reordering Commits

Similar to rewriting multiple commits, you can use interactive rebase to reorder or remove commits entirely.  In the example below if you want to remove the "Add cat file" commit and reorder the other two you would take the below interactive rebase script

```
pick f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file
```

and change it to

```
pick 310154e Update README formatting and add blame
pick f7f3f6d Change my name a bit
```

When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies 310154e and then f7f3f6d and then stops.

At this point you effectively changed the order of those commits and remove the "Add-cat-file" commit completely.

***Note:*** This is a rebase command so **DO NOT** modify commits you already pushed.

## The Nuclear Option: filter-branch

The filter-branch option will rewrite huge swathes of your commit history.  **Do not use it unless your project is not public or is worked on by a few people**

There is an alternative to filter-branch which you can find [here](https://github.com/newren/git-filter-repo)

[comment]: <> (TODO: Need to experiment with script above and write that up)

If you are going to use filter-branch it is recommended you try is a backup copy of your repository.

### Removing a file from every commit

This is useful if someone commits a giant binary file by mistake, or if someone commits a file with a password and you want to make the project public.

To remove a file called password.txt you would use the command below.  This command will remove the file passwords.txt from every commit whether it exists or not. 

`git filter-branch --tree-filter 'rm -f passwords.txt' HEAD`

The `--tree-filter` option runs the specified command after each checkout of the project and then recommits the result.

If you want to run filter-branch on all of your branches you can pass the `--all` command.

### Changing email address globally

The command below can globally update your email address.  You need to be careful to change only the email addresses that are yours so use the `--commit-filter`.  **This command will change every single commit in your history not just those that hve the matching email address.**

### Making a subdirectory the new root

Suppose you have imported from another source control system and have subdirectories that make no sense (trunk, tags, etc.).  If you want to make the trunk subdirectory the new project root for every commit you can use the below command.

`git filter-branch --subdirectory-filter trunk HEAD`

```
git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "myemail@mydomain" ];
        then
            GIT_AUTHOR_NAME="Your Name";
            GIT_AUTHOR_EMAIL="myemail@mydomain";
            git commit-tree "$@";
        else
            git commit-tree "$@";
        fi' HEAD
```

Now your new project root is what was in the trunk subdirectory.  Git will also automatically remove commits that did not effect the subdirectory.

[comment]: <> (TODO: The below is good intro content that needs to not be buried in this file)