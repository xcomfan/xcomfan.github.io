---
layout: page
title: "Committing Your Work"
permalink: /gitref/comitting/rewrite_commits
---

## Rewriting commit history

### Interactive rebase

[comment]: <> (TODO: Need a place where I clearly explain what HEAD is.)

Git does not have a modify history tool, but you can use the rebase tool to rebase a series of commits onto the HEAD that they were originally based on.

With the interactive rebase tool you can stop after each commit you want to modify to change the commit message, add files to the commit or do whatever you wish.

For example if you want to change the last 3 commits you would use the command

`git rebase -i HEAD~3`

The -i option is for interactive rebase

***Note:*** This is a rebase command so **DO NOT** modify commits you already pushed to a remote repository.

Once you run the above command, Git will bring up an editor with a list of commits you selected listed newest first. The editor shows a script which the rebase will run as well as some hint information.

You need to edit this script replacing the word `pick` with one of the commands from the hint information provided.

If the command you write for a specific commit requires interactive rebase to give you a chance to make changes; when you save and exit the editor Git will rewind to the last commit in the list and start executing the script.  When it gets to the action that requires your input (`edit` or `reword` commands for example) Git will drop you into the command line with some hint information.  At this point you can make the needed changes and use `git commit --amend` to modify the commit the script stopped you at.  Once you are done editing the commit you can use the command `git rebase --continue` to continue executing the interactive rebase script.

When you save and exit the editor, Git will rewind you to the last commit in the list and drops you at the command line with some hint information displayed.

Once you are done modifying all the selected commits you will have a rewritten history.

If your want practice with interactive rebase go to [git-rebase.io](https://git-rebase.io)

### Squashing Commits

You can use the interactive rebase to take a series of commits and squash them into a single commit.  A common use for this is if you have multiple local commits that you with to squash into a single commit before pushing it to a remote repository.

First run the rebase command to go back the desired amount of commits

`git rebase -i HEAD~3` where the number after `~` is how many commits you want to squash.

In the interactive rebase editor replace the `pick` keyword with `squash` on the lines representing the commits you with to squash.  Note that you need to have the first commit in the list presented set as pick.  You cannot squash without a previous commit which you are essentially squashing things into.

Once you have made you `squash` selections, ave the file and git will present you with another editor window this time for modifying the commit message.  Here you can set what the commit message will be for the squashed set of commits.  Once you save the changes Git will squash the commits.

[comment]: <> (TODO: We can keep the reference clean, but link to a page where there is a working example to give a better idea of how this works in real life not just with words.)

***WARNING:*** *Only squash commits that are in your local repository and have not been pushed to a remote repository.  Squashing previously pushed commits and force pushing the branch will cause problems for your collaborators.*

### Splitting Commits

The process of splitting a commit involves using interactive rebase undo your commits up to the commit you with to split.  You then rest the commit you wish to split and proceed to make as many new commits as needed to split up your commit.  Once you are done making commits that are the split version of the commit you are splitting you tell git rebase to continue and it re applies the commits made after the commit which was split.

To start the process you first need to run the `git rebase -i HEAD~3` command where the number after the `~` is how many commits you need to go back to get tot he commit you want to split.

[comment]: <> (TODO: Should check if there is a way to specify the hash of the commit instead of counting how far back we need to go.)

In the script generated by the `rebase -i` command change the instruction on the commit you wish to split from `pick` to `edit`.

Once you save the changes to the script generated by interactive rebase you will be dropped at the command line with the rebase script stopped at the commit you wish to split.  You can use `git status` to check where in the interactive rebase script you are.

At this point you want to reset the commit you are on (the commit we are splitting).  You can do this with the command `git reset HEAD^`.  At this point the commit you are slitting has been undone and you can make as many changes and commits as you want to split the commit in a manner you desire.  Just use `git add some_file.txt` and `git commit -m 'One of the changes int the commit being split` to make as many changes as you need.

When done with committing the changes you are splitting the single commit into, use the command `git rebase --continue`.  At this point Git will re apply the changes that came after the commit you split.  You can validate that the split worked by viewing the commit history via `git log`.

***WARNING:*** *Only split commits that are in your local repository and have not been pushed to a remote repository.  Splitting previously pushed commits and force pushing the branch will cause problems for your collaborators.*

### Deleting a Commit

Interactive rebase can also delete a commit.

To delete a commit begin interactive rebase the view the `git rebase -i HEAD~3` command (where 3 is the number of commits we wish to go back) and in the script that interactive rebase has you edit, put the word drop before the commit you want to delete.

***WARNING:*** The content of the commit which you delete will also be deleted from your repository.  For example if the commit you delete adds a file a.txt; a.txt will be removed from your repository.

Because of the way Git builds commit objects, deleting a commit will cause the rewriting of all the commits that follow it.  The further back you go, the more commits need to be created which can cause lots of merge conflicts.  If you get partway through a change like this and want to abort you can use the command below to return your repo to its state before you attempted the rebase.

`git rebase --abort`

If you finish a rebase and decide its not what you want, you can use git reflog to recover an earlier version of your branch.

[comment]: <> (TODO: Need a link to reflog details also put this at top in section that covers how to use rebase as it applies to all these changes.?)

### Reordering Commits

Similar to rewriting multiple commits, you can use interactive rebase to reorder or remove commits entirely.  In the example below if you want to remove the "Add cat file" commit and reorder the other two you would take the below interactive rebase script

```
pick f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file
```

and change it to

```
pick 310154e Update README formatting and add blame
pick f7f3f6d Change my name a bit
```

When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies 310154e and then f7f3f6d and then stops.

At this point you effectively changed the order of those commits and remove the "Add-cat-file" commit completely.

***Note:*** This is a rebase command so **DO NOT** modify commits you already pushed.

## The Nuclear Option: filter-branch

The filter-branch option will rewrite huge swathes of your commit history.  **Do not use it unless your project is not public or is worked on by a few people**

There is an alternative to filter-branch which you can find [here](https://github.com/newren/git-filter-repo)

[comment]: <> (TODO: Need to experiment with script above and write that up)

If you are going to use filter-branch it is recommended you try in a backup copy of your repository.

### Removing a file from every commit

This is useful if someone commits a giant binary file by mistake, or if someone commits a file with a password and you want to make the project public.

To remove a file called password.txt you would use the command below.  This command will remove the file passwords.txt from every commit whether it exists or not. 

`git filter-branch --tree-filter 'rm -f passwords.txt' HEAD`

The `--tree-filter` option runs the specified command after each checkout of the project and then recommits the result.

If you want to run filter-branch on all of your branches you can pass the `--all` command.

### Changing email address globally

The command below can globally update your email address.  You need to be careful to change only the email addresses that are yours so use the `--commit-filter` option.  **This command will change every single commit in your history not just those that hve the matching email address.**

[comment]: <> (TODO: Git tells you not do do this so try out the utility they suggest.)

```
git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "myemail@mydomain" ];
        then
            GIT_AUTHOR_NAME="Your Name";
            GIT_AUTHOR_EMAIL="myemail@mydomain";
            git commit-tree "$@";
        else
            git commit-tree "$@";
        fi' HEAD
```

### Making a subdirectory the new root

Suppose you have imported from another source control system and have subdirectories that make no sense (trunk, tags, etc.).  If you want to make the trunk subdirectory the new project root for every commit you can use the below command.

`git filter-branch --subdirectory-filter trunk HEAD`

Now your new project root is what was in the trunk subdirectory.  Git will also automatically remove commits that did not effect the subdirectory.